<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Clean Code - Critical Analysis</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <!-- Basic SEO Meta Tags -->
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="title" content="Clean Code - A Critical Analysis">
        <meta name="description" content="A modern critique of Robert C. Martin's Clean Code. This book evaluates its principles, explores real-world software development challenges, and presents alternative approaches to writing maintainable code.">
        <meta name="keywords" content="Clean Code, software development, coding best practices, refactoring, code readability, programming critique">
        <meta name="author" content="bugzmanov">
        <meta name="robots" content="index, follow">
        
        <!-- Open Graph (OG) Meta Tags for Social Media -->
        <meta property="og:title" content="Clean Code - A Critical Analysis">
        <meta property="og:description" content="A deep dive into Clean Code's impact, its shortcomings, and what modern developers should do instead.">
        <meta property="og:type" content="book">
        <meta property="og:url" content="https://bugzmanov.github.io/cleancode-critique/">
        <meta property="og:image" content="https://bugzmanov.github.io/cleancode-critique/images/is_this_code_clean.png">
        
        <!-- Twitter Card Meta Tags -->
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" content="Clean Code - A Critical Analysis">
        <meta name="twitter:description" content="A modern critique of Clean Code, evaluating its relevance and offering alternative programming best practices.">
        <meta name="twitter:image" content="https://bugzmanov.github.io/cleancode-critique/images/is_this_code_clean.png">
        <meta name="twitter:site" content="@bugzmanov">
        
        <!-- Canonical URL -->
        <link rel="canonical" href="https://bugzmanov.github.io/cleancode-critique/">
        
        <!-- Favicon -->
        <link rel="icon" type="image/png" href="https://bugzmanov.github.io/cleancode-critique/favicon.svg">
        

        <meta name="description" content="A modern critique of Robert C. Martin&#x27;s &#x27;Clean Code,&#x27; evaluating its principles, real-world applicability, and alternative approaches to software development. This book explores the nuances of code quality, refactoring strategies, and the evolution of programming best practices beyond Clean Code&#x27;s rigid rules.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/custom.css">
        <link rel="stylesheet" href="theme/css/custom-flex.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Clean Code - Critical Analysis</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/buhzmanov/cleancode-critique" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="text-align:center; padding-top:30px"><img src="./images/is_this_code_clean.png" width="50%"/></div>
<h1 id="clean-code---critical-analysis"><a class="header" href="#clean-code---critical-analysis">Clean Code - Critical Analysis</a></h1>
<p>Clean code is probably the most recommended book to entry level engineers and junior developers. While it might have been good recommendation in the past, I don't believe that's the case anymore.</p>
<p>After revisiting the book in 2023 I was surprised to notice that:</p>
<ul>
<li>The book hasn't aged well</li>
<li>Much of its advice ranges from questionable to harmful</li>
<li>Examples are the worst part of the book. By any objective metrics, many would qualify as "bad code."</li>
<li>Lazer focus on a wrong thing and attempt to sell it as the solution to everything. Code readability is important, it is not the only one aspect</li>
<li>Despite being an entry-level book, it has these vibes of implied superiority, potentially giving the readers an undeserved sense of expertise</li>
</ul>
<p>For a significantly shorter critque of the book, check out <a href="https://qntm.org/clean">qntm's critique</a>.
I mostly agree with qntm assessment. But it's a bit too emotional and personal and doesn't cover the parts i find the most harmful.</p>
<h3 id="recommended-alternatives"><a class="header" href="#recommended-alternatives">Recommended Alternatives</a></h3>
<p>If you're just starting your career and seeking books to improve your coding skills, I suggest these instead:</p>
<ul>
<li>
<p><a href="https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201">A Philosophy of Software Design</a> <br/>
While not explicitly positioned as such, this book effectively counters many "Clean Code" principles.
It's particularly helpful for unlearning Clean Code style of coding.</p>
</li>
<li>
<p><a href="https://www.amazon.com/Balancing-Coupling-Software-Design-Addison-wesley/dp/0137353480">The Art of Software Design: Balancing Flexibility and Coupling</a>
A deep dive into software complexity through abstraction, coupling, and modularity. It works as an excellent companion to "A Philosophy of Software Design".</p>
</li>
</ul>
<p>Also Robert Martin is working on the second edition of <em>Clean Code</em>. It will be fun to see how much of this critique will become irrelevant ðŸ˜ƒ</p>
<div style="text-align:center"> 
    <a target="_blank" href="https://www.reddit.com/r/programming/comments/1eo2lo5/uncle_bob_martin_i_am_in_the_midst_of_writing_the/"><img src="./images/second-ed-tweet.png" style="width:40%"></img></a>
</div> 
<h2 id="intended-audience"><a class="header" href="#intended-audience">Intended Audience</a></h2>
<ul>
<li><strong>For those recommending "Clean Code"</strong>:<br/>
You may have read the book over a decade ago and found it useful at the time. This might help you reconsider.</li>
<li><strong>For those confused after reading "Clean Code"</strong>:<br/>
Youâ€™re not alone. The book can be confusing, and you might find better practical advice in modern alternatives</li>
<li><strong>For those who enjoyed "Clean Code"</strong>:<br />
<a href="https://github.com/hwayne/awesome-cold-showers">"It's great when people get excited about things, but sometimes they get a little too excited."</a><br />
I hope this critique would help you to see more nuance.</li>
</ul>
<h3 id="a-note-to-all-readers"><a class="header" href="#a-note-to-all-readers">A Note to All Readers</a></h3>
<p>This page exists as a reference for anyone. Agree or disagree, contributions to the critique are welcome via <a href="https://github.com/bugzmanov/cleancode-critique">GitHub</a>.</p>
<p><br/><br/></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-1-clean-code"><a class="header" href="#chapter-1-clean-code">Chapter 1: Clean Code</a></h1>
<p>Here is Martin's main thesis: <strong>bad code destroys companies</strong>.</p>
<p>Ergo: Writing bad code is a mistake, and no excuse can justify it.</p>
<div class="book-quote">
I know of one company that, in the late 80s, wrote a killer app. It was very popular, and lots of professionals bought and used it. But then the release cycles began to stretch. Bugs were not repaired from one release to the next. Load times grew and crashes increased. I remember the day I shut the product down in frustration and never used it again. The company went out of business a short time after that.
<p>Two decades later I met one of the early employees of that company and asked him what had happened. The answer confirmed my fears. They had rushed the product to market and had made a huge mess in the code. As they added more and more features, the code got worse and worse until they simply could not manage it any longer.</p>
<p><em>It was the bad code that brought the company down.</em></p>
</div>
<h4 id="a-counter-anecdote"><a class="header" href="#a-counter-anecdote">A Counter-Anecdote:</a></h4>
<blockquote>
<p>"Oracle Database 12.2.</p>
<p>It is close to 25 million lines of C code. What an unimaginable horror! You can't change a single line of code in the product without breaking 1000s of existing tests. Generations of programmers have worked on that code under difficult deadlines and filled the code with all kinds of crap.</p>
<p>Very complex pieces of logic, memory management, context switching, etc. are all held together with thousands of flags. The whole code is ridden with mysterious macros that one cannot decipher without picking a notebook and expanding relevant parts of the macros by hand. It can take a day to two days to really understand what a macro does.</p>
<p>Sometimes one needs to understand the values and the effects of 20 different flags to predict how the code would behave in different situations. Sometimes 100s too! I am not exaggerating."</p>
<p>From <a href="https://news.ycombinator.com/item?id=18442941">HN: What's the largest amount of bad code you have ever seen work?</a></p>
</blockquote>
<p>As horrific as this sounds, Oracle won't go out business <a href="https://www.macrotrends.net/stocks/charts/ORCL/oracle/gross-profit">anytime soon</a>. I can bet my life on that.</p>
<h4 id="a-personal-anecdote"><a class="header" href="#a-personal-anecdote">A personal anecdote:</a></h4>
<p>I worked in a small Series-A startup that had the most elegant code I've ever seen. The code was highly attuned to the domain model, well-structured and was so ergonomic that adding new features was a joy. It was the third iteration of the codebase. They run out of money. <del>It was the hunt for the clean code that brought the company down</del>. Nah. I'm kidding. World of business is far more complex than just code quality.</p>
<p>Reading Clean Code in 2009, the idea that bad code being the root of all evil impressed me and I became a convert. It took me a decade to finally admit "ok. this doesn't match with reality." "Bad" code is pretty much the norm. Success or failure of an enterprise has nothing to do with it. And code that's good today will be very questionable from tomorrow's standards (this book is a perfect illustration of this).</p>
<p>The focus on "cleanliness" of the code often feels like bike-shedding. The real challenge is to keep the balance between complexity vs available resources to manage it.
Oracle can afford to have complex code base as they have enough resources and (<em>I'm speculating</em>) keep throwing more bodies at the problem.</p>
<div class="book-quote">
Of course you have been impeded by bad code. So thenâ€”why did you write it? <...> 
<p>Were you trying to go fast? Were you in a rush? Probably so. Perhaps you felt that you didn't have time to do a good job</p>
</div> 
<p>"Not having enough time" might be an easy excuse and rationalization. But in my experience, I'm writing bad code because:</p>
<ul>
<li>I don't know that it is bad</li>
<li>I don't know how to make it good within the constraints</li>
<li>The existing architecture or design</li>
</ul>
<p>More often, it's a combination: accepting the existing design because I don't know how to make it better.</p>
<p>You don't know what you don't know. Unfortunately, just reading "Clean Code" helps very little with discovering unknowns.</p>
<div class="emphasis-block">
    What might help is diving in and working on high quality code bases, having an experienced mentor, learning and studying different domains, ecosystems, languages and frameworks.
</div>
<h2 id="the-boy-scout-rule"><a class="header" href="#the-boy-scout-rule">The Boy Scout Rule</a></h2>
<p>"Leave the campground cleaner than you found it". This is the call to action: always improve code that you're touching.</p>
<p>In corporate america anything that has a catchy name has a chance to spread. I've heard of CTO at a mid-size company who knew two things about IT: how to hire contractors to adapt <a href="https://scaledagileframework.com/">Scaled Agile Framework</a> and "the Boy Scout Rule" of programming.</p>
<div class="book-quote">
Can you imagine working on a project where the code simply got better as time passed?
</div>
<p>This sounds appealing and might work on a small scale (think couple lines of code) and in isolation. But on this scale, it quickly hits diminishing returns. Applied on a larger scale, it creates chaos, random failures, and placing unnecessary burden on people working with the system and the codebase.</p>
<!-- The analogy: you wake up every day in your apartment, and sometimes some of your stuff (furniture, clothes, appliances) are misplaced, moved or reorganized. Even if it's a slightly better organization, this will drive you insane if this will keep happening. --> 
<p>What makes things worse: <strong>cleanliness of code is not an objective metric</strong>.</p>
<p>In a campground, everyone agrees a plastic cup is trash and doesnâ€™t belong. In code, readability and elegance are far more subjective.
The most elegant OCaml code will be unreadable and weird in the eyes of average java Bob.</p>
<div class="small-image-right">
 <img src="./images/tidy_first.png"/>
</div>
<p>Kent Beck offers the idea of tidyings - small code changes that will unquestionably improve code base. While reading the book "Tidy first?" you'll notice two things:</p>
<ul>
<li>These are very small changes</li>
<li>Question mark in the title of the book</li>
</ul>
<p>Clean Code advocates for significantly more radical interventions.
<br/>
<br/>
<br/>
<br/></p>
<p>The boy scout rule is the opposite of:
<br/></p>
<div class="big-emphasis">Do not "fix" stuff that is not broken</div>
<center style="font-style:italic">(this needs a catchy name)</center>
<p>To Sum Up:</p>
<p>Focusing obsessively on clean code often misses the bigger picture. The real game lies in managing complexity while balancing the resources and the constraints.</p>
<p><br/><br/></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2-meaningful-names"><a class="header" href="#chapter-2-meaningful-names">Chapter 2: Meaningful names</a></h1>
<p>I generally agree with the theme of this chapter: names are important. Naming is the main component of building abstractions and abstraction boundaries.
In smaller languages like C or Go-Lang, naming is <em>the</em> primary mechanism for abstraction.</p>
<p>Naming brings the problem domain into the computational domain:</p>
<pre><code class="language-java">static int TEMPERATURE_LIMIT_F = 1000;
</code></pre>
<p>Named code constructs â€” such as functions and variables â€” are the building blocks of composition in virtually every programming paradigm.</p>
<blockquote>
<p>Names are a form of abstraction: they provide a simplified way of thinking about a more complex underlying entity. Like other forms of abstraction, the best names are those that focus attention on what is most important about the underlying entity while omitting details that are less important.</p>
<p>Fom <a href="https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201">"Philosophy of software design"</a></p>
</blockquote>
<p>However, I disagree with Clean Code's specific approach to naming and its examples of "good" names. Quite often the book declares a good rule but then shows horrible application.</p>
<h2 id="use-intention-revealing-names"><a class="header" href="#use-intention-revealing-names">Use intention-revealing names</a></h2>
<p>The advocated principle is the title - the name should reveal intent. But the application:</p>
<div class="book-quote">
The name of a variable, function, or class, should answer all the big questions. It should tell you why it exists, what it does, and how it is used. If a name requires a comment, then the name does not reveal its intent.
</div>
<p>This sounds like an impossible task. First, the name that reveals all of those details fails to be an abstraction boundary.
Second, what you notice in many examples in this book that this approach to naming leads to using "description as a name".</p>
<p>Martin presents 3 versions of the same code:</p>
<div class="code-comparison">
    <div class="code-column">
    <pre><code class="language-java">
public List&lt;int[]&gt; getThem() {
  List&lt;int[]&gt; list1 
       = new ArrayList&lt;int[]&gt;();
  for (int[] x : theList)
    if (x[0] == 4)
      list1.add(x);
  return list1;
} </pre></code>
       <div class="code-column-title" style="padding-top:10px; text-align: center; margin-bottom: 0px;">(Might be) Obfuscated and unrealistic</div>
    </div>
    <div class="code-column">
        <pre><code class="language-java">
public List&lt;int[]&gt; getFlaggedCells() {
  List&lt;int[]&gt; flaggedCells 
     = new ArrayList&lt;int[]&gt;();
  for (int[] cell : gameBoard)
    if (cell[STATUS_VALUE] == FLAGGED)
      flaggedCells.add(cell);
  return flaggedCells;
}</code></pre>
        <div class="code-column-title" style="padding-top:10px; text-align: center; margin-bottom: 0px;">(Migh be) Good enough</div>
    </div>
    <div class="code-column">
        <pre><code class="language-java">
public List&lt;Cell&gt; getFlaggedCells() {
  List&lt;Cell&ht; flaggedCells 
      = new ArrayList&lt;Cell&gt;();
  for (Cell cell : gameBoard)
    if (cell.isFlagged())
        flaggedCells.add(cell);
  return flaggedCells;
}
</code></pre>
        <div class="code-column-title" style="padding-top:10px; text-align: center; margin-bottom: 0px;">(Might be) Premature abstraction</div>
    </div>
</div>
<p>My main disagreement is this: not all code chunks need a name. In modern languages, this method can be a one-liner:</p>
<pre><code class="language-scala">gameBoard.filter(cell =&gt; cell(STATUS_VALUE) == FLAGGED)
</code></pre>
<p>That's it. This code can be inlined and used as is.</p>
<p>While <code>getFlaggedCells</code> looks like an improvement over obfuscated <code>getThem</code>, it's not really a name, it's a description of what the method does.
If the description is as long as the code, it's often redundant.</p>
<p>Martin writes about it in passing: "if you can extract another function from it with <strong>a name that is not merely a restatement of its implementation</strong>".<br/>
But he violates this principle quite often.</p>
<p>If for readability alone, I'd argue that the second version is as clear as the third and introducing Cell abstraction is an overkill.</p>
<div class="collapsible-rant">
    <div class="collapsible-header">
        <span class="collapsible-title">To be fair there are good reasons to introduce Cell abstraction, but also there are reasons not to</span>
        <span class="collapsible-arrow">â†“</span>
    </div>
    <div class="collapsible-content">
        <code>List&lt;int[]&gt;</code> is a generic type - devoid of meaning without a context. <br/><code>List&lt;Cell&gt;</code> - has more semantic meaning and is harder to misuse.<br/>
        <pre><code class="language-java">
List&lt;int[]&gt; list = getFlaggedCells();
list.get(0)[0] = list.get(0)[1] - list.get(0)[0];
        </code></pre>
        This compiles and runs, but the transformation is non-sensical and will corrupt data (the first element is a status field). <br/> 
        <code>List&lt;Cell&gt;</code> has a better affordance than <code>List&lt;int[]&gt;</code>, and makes such mistakes less likely. But improved affordance comes from the specialized type, not just the name.<br/><br/>
        But there is a the downside - specialized types needs specialized processing code. 
&nbsp;
        Serialization libraries, for example, would have support for <code>List&lt;int[]&gt;</code> out of the box, 
        but would need custom ser-de for the Cell class.<br/><br/>
        Since Clean Code, Robert Martin has embraced Clojure and functional programming. One of the tenets of Clojure philosophy: <b>use generic types to represent the data</b> and you'll have enormous library of processing functions that can be reused and combined.<br/>
        I'm curious if he would ever finish the second edition and if he had changed his mind about types.
    </div>
</div>
<!--To be fair there are good reasons to introduce Cell abstraction, but also there are reasons not to. `List<int[]>` is a generic type - devoid of meaning without a context. `List<Cell>` - has more semantic meaning and is harder to misuse.-->
<!---->
<!--```java-->
<!--List<int[]> list = getFlaggedCells();-->
<!--list.get(0)[0] = list.get(0)[1] - list.get(0)[0];-->
<!--```-->
<!---->
<!--This compiles and runs, but the transformation is non-sensical and will corrupt data (the first element is a status field). `List<Cell>` has a better affordance than `List<int[]>`, and makes such mistakes less likely. But improved affordance comes from the specialized type, not just the name.-->
<!---->
<!--It comes with the downside - specialized types needs specialized processing code. Serialization libraries, for example, would have support for `List<int[]>` out of the box, -->
<!--but would need custom ser-de for the Cell class.-->
<!---->
<!--Since Clean Code, Robert Martin has embraced Clojure and functional programming. One of the tenets of Clojure philosophy: *use generic types to represent the data* and you'll have enormous library of processing functions that can be reused and combined.-->
<!---->
<!--I'm curious if he would ever finish the second edition and if he had changed his mind about types.-->
<!---->
<h2 id="avoid-disinformation--use-problem-domain-name"><a class="header" href="#avoid-disinformation--use-problem-domain-name">Avoid disinformation ... Use Problem Domain Name</a></h2>
<p>Martin pretty much advocates for informative style of writing in code: be clear, avoid quirks and puns.</p>
<p>These are examples of "good" names from his perspective:</p>
<ul>
<li><code>bunchOfAccounts</code></li>
<li><code>XYZControllerForEfficientStorageOfStrings</code></li>
</ul>
<div class="book-quote">
Do not refer to a grouping of accounts as an accountList unless it's actually a List. The word list means something specific to programmers. If the container holding the accounts is not actually a List, it may lead to false conclusions. So accountGroup or bunchOfAccounts or just plain accounts would be better.
</div>
<p>This might be stylistic preferences, but <code>accountsList</code> is easier to read and write than <code>bunchOfAccounts</code>: it's shorter and has fewer words - it is more concise. If by looking at word List the first thing you're thinking is <code>java.util.List</code>, then you might need some time away from Java. Touch some grass, write some Haskell.</p>
<div class="subtle-paragraph">
XYZControllerForEfficientStorageOfStrings - this is not a name - it's an essay. It tells the whole story of (web) application working with strings and storing them efficiently.
</div>
<p>Martin states that acronyms and word shortenings are bad, but doesn't see the problem in a name that has 7 words and 40 characters in it.</p>
<p>There is a simple solution to this - comments that expand acronyms and explain shortenings. But because Martin believes that <a href="./chapter_4.html">comments are a failure</a>, he has to insist on using essays as a name.</p>
<p>By the end of the chapter he finally mentions:</p>
<div class="book-quote">
Shorter names are generally better than longer ones, so long as they are clear.
<p>...The resulting names are more precise, which is the point of all naming.</p>
</div>
<p>These are really good points! But most of the examples in the chapter are not aligned with them. And I don't think "short and concise naming" is a takeaway people are getting from reading this chapter.</p>
<p>If anything, in most examples he proposed to replace short (albeit cryptic) names with 3-4 word long slugs.</p>
<div class="collapsible-rant">
    <div class="collapsible-header">
        <span class="collapsible-title">Opinion: Code Conventions for the Java Programming Language</span>
        <span class="collapsible-arrow">â†“</span>
    </div>
    <div class="collapsible-content">
        Pascal and Camel case in Java was proposed in <a href="https://checkstyle.sourceforge.io/styleguides/sun-code-conventions-19990420/CodeConventions.doc8.html">Sun's Java Style</a> as a way to enforce <b>"names should be short yet meaningful"</b>. 
        <br/><br/>
        The idea being that <code>ItIsReallyUncomfortableToReadLongSentencesWrittenInThisStyle</code>. Hence people will be soft forced to limit the size of names.<br/>
        <br/>
        The assumption was wrong.
        <br/><br/>
        <div style="text-align:center"><img src="./images/names.png" width="70%" style="filter: brightness(85%)"/></div>
    </div>
</div>
<!--Pascal and Camel case in Java was proposed in Sun's Java Style as way to enforce "names should be short yet meaningful". <br/>-->
<!--The idea being that `ItIsReallyUncomfortableToReadLongSentencesWrittenInThisStyle`. Hence people will be soft forced to limit the size of names.<br/>-->
<!--The assumption was wrong.-->
<!---->
<!--<div style="text-align:center"><img src="./images/names.png" width="70%"/></div>-->
<h2 id="add-meaningful-context"><a class="header" href="#add-meaningful-context">Add meaningful context</a></h2>
<p>I believe this was my first big WTF moment in the book:</p>
<div class="code-comparison">
    <div class="code-column" style="flex:0">
        <div class="code-column-title">Original Code: </div>
        <pre class="ignore"><code class="language-java">private void printGuessStatistics(char candidate, 
                                  int count) {   
    String number;
    String verb;
    String pluralModifier;
    if (count == 0) {
        number = "no";
        verb = "are";
        pluralModifier = "s";
    } else if (count == 1) {
        number = "1";
        verb = "is";
        pluralModifier = "";
    } else {
        number = Integer.toString(count);
        verb = "are";
        pluralModifier = "s";
    }
    String guessMessage = String.format(
        "There %s %s %s%s", verb, number, 
        candidate, pluralModifier
    );
    <span class="code-comment-trigger">â–º</span><span class="reviewable-line">print(guessMessage);<span class="code-comment">Instead of printing, the method should just return guessMessage String result</span></span>
    &nbsp;
    &nbsp;
}</code></pre>
    </div>
    <div class="code-column">
        <div class="code-column-title">Proposed rewrite:</div>
        <pre class="ignore"><code class="language-java">public class GuessStatisticsMessage {
    private String number;
    private String verb;
    private String pluralModifier;
&nbsp; 
    public String make(char candidate, int count) {
        createPluralDependentMessageParts(count);
        return String.format(
                "There %s %s %s%s", 
                verb, number, candidate, pluralModifier );
    }
&nbsp; 
    private void createPluralDependentMessageParts(int count) {
        if (count == 0) {
            thereAreNoLetters();
        } else if (count == 1) {
            thereIsOneLetter();
        } else {
            thereAreManyLetters(count);
        }
    }
&nbsp; 
    private void thereAreManyLetters(int count) {
        number = Integer.toString(count);
        verb = "are";
        pluralModifier = "s";
    }
&nbsp; 
    private void thereIsOneLetter() {
        number = "1";
        verb = "is";
        pluralModifier = "";
    }
&nbsp; 
    private void thereAreNoLetters() {
        number = "no";
        verb = "are";
        pluralModifier = "s";
    }
}</code></pre>
    </div>
</div>
<p>In no way the second option is better than the first one. The original has only one problem: side-effects. Instead of printing to the console it should have just return String.</p>
<p>And that is it:</p>
<ul>
<li>1 method, 20 lines of code, can be read top to bottom,</li>
<li>3 mutable local variables to capture local mutable state that can not escape.</li>
<li>It is thread-safe. I's impossible to misuse this API.</li>
</ul>
<p>Second option:</p>
<ul>
<li>5 methods, 40 lines of code, +1 new class with mutable state.</li>
<li>Because it's a class, the state can escape and be observed from the outside.</li>
<li>Which makes it not thread safe.</li>
</ul>
<p>The second option introduced more code, more concepts and more entities, introduced thread safety concerns.. while getting the exactly same results.</p>
<p>It also violates one of the rules laid out in the chapter about method names: "Methods should have verb or verb phrase names". <code>thereIsOneLetter()</code> is not really a verb or a verb phrase.</p>
<p>If I'll try to be charitable here: Martin is creating internal Domain Specific Language(DSL) for a problem.</p>
<div class="subtle-paragraph">
A good indicator of an internal DSL: there are parts of API that doesn't make sense outside specific context/grammar. 
<p>For example, <code>new GuessStatisticsMessage().thereAreNoLetters()</code> looks weird and doesn't make sense.</p>
<p>On the other hand, language consturcts are presented in a somewhat declarative style:</p>
<pre><code class="language-java">private void thereAreNoLetters() {
    number = "no";
    verb = "are";
    pluralModifier = "s";
}

private void thereIsOneLetter() {
    number = "1";
    verb = "is";
    pluralModifier = "";
}
</code></pre>
<p>I hope you agree that methods like this is not a typical Java. If anything, this looks closer to typical ruby.</p>
</div>
<p>But ultimately, object-oriented programming and domain-specific languages are unnessary for the simple task.
In a powerful-enough language, keeping this code procedural gives the result that is short and easy to understand:</p>
<pre><code class="language-scala">def formatGuessStatistics(candidate: Char, count: Int): String = {   
   count match {
       case i if i &lt; 0 =&gt; throw new IllegalArgumentException(s"count=$count: negative counts are not supported")
       case 0 =&gt; s"There are no ${candidate}s"
       case 1 =&gt; s"There is 1 ${candidate}"
       case x =&gt; s"There are $x ${candidate}s"
   }
}
</code></pre>
<br/>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3-functions"><a class="header" href="#chapter-3-functions">Chapter 3: Functions</a></h1>
<p>The chapter begins by showcasing an example of "bad" code:</p>
<div class="book-quote">
<pre><code class="language-java">public static String testableHtml(PageData pageData, boolean includeSuiteSetup) throws Exception {
    WikiPage wikiPage = pageData.getWikiPage();
    StringBuffer buffer = new StringBuffer();
    if (pageData.hasAttribute("Test")) {
      if (includeSuiteSetup) {
        WikiPage suiteSetup =
         PageCrawlerImpl.getInheritedPage(
                 SuiteResponder.SUITE_SETUP_NAME, wikiPage
         );
        if (suiteSetup != null) {
         WikiPagePath pagePath = suiteSetup.getPageCrawler().getFullPath(suiteSetup);
         String pagePathName = PathParser.render(pagePath);
         buffer.append("!include -setup .")
               .append(pagePathName)
               .append("\n");
        }
      }
      WikiPage setup = 
        PageCrawlerImpl.getInheritedPage("SetUp", wikiPage);
      if (setup != null) {
        WikiPagePath setupPath = wikiPage.getPageCrawler().getFullPath(setup);
        String setupPathName = PathParser.render(setupPath);
        buffer.append("!include -setup .")
              .append(setupPathName)
              .append("\n");
      }
    }
    buffer.append(pageData.getContent());
    if (pageData.hasAttribute("Test")) {
      WikiPage teardown = PageCrawlerImpl.getInheritedPage("TearDown", wikiPage);
      if (teardown != null) {
        WikiPagePath tearDownPath = wikiPage.getPageCrawler().getFullPath(teardown);
        String tearDownPathName = PathParser.render(tearDownPath);
        buffer.append("\n")
              .append("!include -teardown .")
              .append(tearDownPathName)
              .append("\n");
      }
       if (includeSuiteSetup) {
         WikiPage suiteTeardown =
           PageCrawlerImpl.getInheritedPage(
                   SuiteResponder.SUITE_TEARDOWN_NAME,
                   wikiPage
           );
         if (suiteTeardown != null) {
           WikiPagePath pagePath = suiteTeardown.getPageCrawler().getFullPath (suiteTeardown);
           String pagePathName = PathParser.render(pagePath);
           buffer.append("!include -teardown .")
                 .append(pagePathName)
                 .append("\n");
         }
       }
     }
     pageData.setContent(buffer.toString());
     return pageData.getHtml();
  }
</code></pre>
</div>
<p>And the proposes refactoring:</p>
<div class="book-quote">
<pre><code class="language-java">public static String renderPageWithSetupsAndTeardowns(PageData pageData, boolean isSuite) throws Exception {
    boolean isTestPage = pageData.hasAttribute("Test");
    if (isTestPage) {
        WikiPage testPage = pageData.getWikiPage();
        StringBuffer newPageContent = new StringBuffer();
&nbsp;
        includeSetupPages(testPage, newPageContent, isSuite);
        newPageContent.append(pageData.getContent());
        includeTeardownPages(testPage, newPageContent, isSuite);
&nbsp;
        pageData.setContent(newPageContent.toString());
    }
&nbsp;
    return pageData.getHtml();
}
</code></pre>
</div>
<p>The original version operates on multiple levels of detalization and juggles multiple domains at the same time:</p>
<ul>
<li><em>API for fitness objects</em>: working with <code>WikiPage</code>, <code>PageData</code>, <code>PageCrawler</code> etc</li>
<li><em>Java string manipulation</em>: Using StringBuffer to optimize string concatenation (it should be StringBuilder).</li>
<li><em>Business logic</em>: Handling suites, tests, setups, and teardowns in a specific order.</li>
</ul>
<p>When everything presented at the same level  it indeed looks very noisy and hard to follow. (the book touches this in <a href="./chapter_32.html">"One Level of Abstraction per Function"</a>)</p>
<p>Martin's trick here is simple: show that smaller code is easier to understand than larger code.
This works because he doesn't show the implementation of <code>includeSetupPages</code> and <code>includeTeardownPages</code></p>
<p>But... extracting non-reusable methods doesnâ€™t actually reduce complexity or code size, at best it just improves navigation.</p>
<p>What objectively reduces code size is removing repetitions (the fancy term - <a href="https://en.wikipedia.org/wiki/Anti-unification">Anti-Unification</a>): the original code as bad as it is can be significantly improved by a small change - extract code duplication into helper method:</p>
<pre><code class="language-java">public static String testableHtml(PageData pageData, boolean includeSuiteSetup) {
    if (pageData.hasAttribute("Test")) { // not a test data page
        return pageData.getHtml(); 
    } 
    WikiPage wikiPage = pageData.getWikiPage();
    List&lt;String&gt; buffer = new ArrayList&lt;&gt;();
    if (includeSuiteSetup) {
        buffer.add(generateInclude(wikiPage, "Suite SetUp", "-setup"));
    }
    buffer.add(generateInclude(wikiPage, "SetUp", "-setup"));

    buffer.append(pageData.getContent());

    buffer.add(generateInclude(wikiPage, "TearDown", "-teardown"));
    if (includeSuiteSetup) {
        buffer.add(generateInclude(wikiPage, "Suite TearDown", "-teardown"))
    }

    pageData.setContent(buffer.stream().filter(String::nonEmpty).join("\n"));
    return pageData.getHtml();
}

private static String generateInclude(WikiPage wikiPage, String path, String command) {
    WikiPage inheritedPage = PageCrawlerImpl.getInheritedPage(path, wikiPage);
    if (inheritedPage != null) {
        WikiPagePath pagePath = inheritedPage.getPageCrawler().getFullPath(inheritedPage);
        String pagePathName = PathParser.render(pagePath);
        return "!include " + command + " ." + pagePathName;
    } else {
        return "";
    }
}
</code></pre>
<p>Is it noisier than Martin's version? Yes. But most people would answer "YES" to the posed question "Do you understand the function after three minutes of study?"
And it's a small change to the original mess.</p>
<div style="text-align:center"><img src="./images/code_compression.png" width="70%"/></div>
<div class="subtle-paragraph">
"Extract a helper" - is one of those tidyings that Kent Beck is advocating - small code changes that definitely improve situation and have small risk.
</div>
<h2 id="the-real-problem"><a class="header" href="#the-real-problem">The real problem</a></h2>
<p>Despite these improvements, we're missing the critical issue: both versions modify the PageData object as a side effect.
Both <code>testableHtml</code> and <code>renderPageWithSetupsAndTeardowns</code> overwrite PageData's content to generate HTML.
This hidden behavior, not the code structure, is the real problem.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="small"><a class="header" href="#small">Small!</a></h2>
<p><span style="font-size:80px; color: red;"> NO! </span>
This is one of the two most harmful ideas in Clean Code (the second one is <a href="./chapter_4.html">"Comments are a failures"</a>).
Bazzilion small functions has become a trademark of "clean-coders" and it fundamentally misunderstands why we break down code.
This is the most damaging idea in this book.</p>
<p>Breaking a system into pieces is an extremely useful technique for:</p>
<ul>
<li>Building reusable components</li>
<li>Keeping unrelated concerns separate</li>
<li>Reducing cognitive load required to reason about components independently</li>
</ul>
<p>However clean code advocates for splitting the code in order to just keep functions short. By itself this is a useless metric.</p>
<p>When components become too small, they:</p>
<ul>
<li>Fail to encapsulate meaningful functionality</li>
<li>Become tightly coupled with other parts</li>
<li>Can't be analyzed independently</li>
</ul>
<p>This defeats the original goals of modularity:</p>
<ul>
<li>Less reusable: Tight coupling makes it harder to use pieces of the system in different contexts.</li>
<li>Harder to understand: You can't reason about pieces in isolationâ€”everything is interconnected</li>
</ul>
<p>You can argue that shorter methods are less complex, but this addresses only <strong>local complexity</strong>.
To understand a system, you have to deal with global complexity - the sum of all the pieces <strong>and how they interact</strong>. A bad split can make global complexity worse.</p>
<p>Most of the time, splitting a function into tiny pieces doesnâ€™t improve much.
This is like cutting a pizza into smaller slices and claiming you've reduced the calories.</p>
<p>My rule of thumb: splitting code should reduce global complexity or code size or both.
If breaking something into smaller pieces makes the overall system harder to understand and/or adds more lines of code, youâ€™ve just made things worse.</p>
<p>Thereâ€™s also the problem of running out of good names when you create too many small functions.
This leads to long, descriptive names that actually make code harder to read:</p>
<pre><code class="language-java">// an example, not from the book
public static String render(PageData pageData, boolean isSuite) throws Exception 
private static String renderPageWithSetupsAndTeardowns(PageData pageData, boolean isSuite) throws Exception 
private static String failSafeRenderPageWithSetupsAndTeardowns(PageData pageData, boolean isSuite) throws Exception 
</code></pre>
<p><strong>PS</strong> Unfortunately, Martin still advocates for this approach:</p>
<center>
    <blockquote class="twitter-tweet" data-media-max-width="560"><p lang="en" dir="ltr">How Small Should a Function be? By Uncle Bob <a href="https://t.co/hhk61RpXSp">pic.twitter.com/hhk61RpXSp</a></p>&mdash; Mohit Mishra (@chessMan786) <a href="https://twitter.com/chessMan786/status/1867877505933471823?ref_src=twsrc%5Etfw">December 14, 2024</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</center>
<br/>
<br/>
<div style="break-before: page; page-break-before: always;"></div><h2 id="one-level-of-abstraction-per-function"><a class="header" href="#one-level-of-abstraction-per-function">One Level of Abstraction per Function</a></h2>
<p>This is a good rule, but as an author of the code you have always a choice: <strong>what is your abstraction</strong>.</p>
<pre><code class="language-java">public static String testableHtml(PageData pageData, boolean includeSuiteSetup) {
    WikiPage wikiPage = pageData.getWikiPage();
    StringBuilder buffer = new StringBuilder();
    boolean isTestPage = pageData.hasAttribute("Test");
    if (isTestPage) {
        if (includeSuiteSetup) {
            buffer.append(generateInclude(wikiPage, SuiteResponder.SUITE_SETUP_NAME, "-setup")).append("\n")
        }
        buffer.append(generateInclude(wikiPage, "SetUp", "-setup")).append("\n")
    }

    buffer.append(pageData.getContent());

    if (isTestPage) {
        buffer.append(generateInclude(wikiPage, "TearDown", "-teardown"))
        if (includeSuiteSetup) {
            buffer.append("\n").append(generateInclude(wikiPage, SuiteResponder.SUITE_TEARDOWN_NAME, "-teardown"))
        }
    }
    pageData.setContent(buffer.toString());
    return pageData.getHtml();
}
</code></pre>
<p>You might say this violates "one level of abstraction":</p>
<div class="book-quote">
There are concepts in there that are at a very high level of abstraction, such as getHtml(); <br/>
others that are at an intermediate level of abstraction, such as: String pagePathName = PathParser.render(pagePath);<br/> 
and still others that are remarkably low level, such as: .append("\n").
</div>
<p>Or.. you could also argue that the domain of this function is to convert PageData into HTML as a raw string.
From that perspective, everything here operates at the same level - transforming structured data into formatted text.</p>
<div class="subtle-paragraph">
"Abstractions are mappings between a complex concrete world and a simple idealized one."
<p>James Koppel <a href="https://www.pathsensitive.com/2022/03/abstraction-not-what-you-think-it-is.html">"Abstraction is not what you think it is"</a></p>
</div>
<p>The key point is that <strong>abstraction is a choice</strong>. Developers define the idealized world their function operates in.
If you decide your abstraction is "PageData to HTML converter," then string operations and HTML generation belong at the same level.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="switch-statements"><a class="header" href="#switch-statements">Switch Statements</a></h2>
<div class="book-quote">
It's hard to make a small switch statement. Even a switch statement with only two cases is larger than I'd like a single block or function to be. It's also hard to make a switch statement that does one thing. By their nature, switch statements always do N things.
</div>
<p>By this logic a method can never have if-else statement - they also do N things.</p>
<p>There was a whole movement of <a href="https://www.antiifprogramming.com/about-the-anti-if.php">anti-if programming</a>.
I'm not quite sure if it's a joke <a href="https://en.algorithmica.org/hpc/pipelining/branchless/">or not</a></p>
<p>Ok, back to Martin:</p>
<div class="book-quote">
<pre><code class="language-java">public Money calculatePay(Employee e) throws InvalidEmployeeType {
    switch (e.type) {
        case COMMISSIONED:
            return calculateCommissionedPay(e);
        case HOURLY:
            return calculateHourlyPay(e);
        case SALARIED:
            return calculateSalariedPay(e);
        default:
            throw new InvalidEmployeeType(e.type);
    }
}
</code></pre>
</div>
<p>Whether this violates the "one thing" rule depends entirely on perspective:</p>
<ul>
<li><em>Low-level view</em>: Four branches doing four different things</li>
<li><em>High-level view</em>: One thing - calculating employee pay</li>
</ul>
<p>Switch statements have bad rep among Java developers:</p>
<ul>
<li>Doesn't look like OOP</li>
<li>Leads to repetition</li>
<li>Lead to bugs when copies get out of sync</li>
</ul>
<p>Starting from Java 13 switch expressions introduced <a href="https://openjdk.org/jeps/354">exhaustive matching</a>, addressing one of these issues.</p>
<pre><code class="language-java">public Money calculatePay(Employee e) throws InvalidEmployeeType {
    return switch (e.type) {
        case COMMISSIONED -&gt; yield calculateCommissionedPay(e);
        case HOURLY       -&gt; yield calculateHourlyPay(e);
        case SALARIED     -&gt; yield calculateSalariedPay(e);
    }
}
</code></pre>
<p>Forgetting to handle a case now causes compile-time errors that's improssible to miss. No extra abstractions needed.</p>
<p>Martin suggests hiding the switch statement behind polymorphism:</p>
<div class="book-quote">
<pre><code class="language-java">public abstract class Employee {
    public abstract boolean isPayday();
    public abstract Money calculatePay();
    public abstract void deliverPay(Money pay);
}
&nbsp;
public interface EmployeeFactory {
    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;
}
&nbsp;
public class EmployeeFactoryImpl implements EmployeeFactory {
    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {
        switch (r.type) {
            case COMMISSIONED:
                return new CommissionedEmployee(r);
            case HOURLY:
                return new HourlyEmployee(r);
            case SALARIED:
                return new SalariedEmploye(r);
            default:
                throw new InvalidEmployeeType(r.type);
        }
    }
}
</code></pre>
</div>
<p>This common approach has serious problems, as Martin's own example shows.</p>
<p>His Employee interface becomes a god object mixing unrelated concerns:</p>
<ul>
<li><code>Employee.isPayday()</code> - couples Employee with payments, agreements, calendars and dates</li>
<li><code>Employee.calculatePay()</code> - couples Employee with financial calculations</li>
<li><code>Employee.deliverPay()</code> - couples Employee with transaction processing and persistence</li>
</ul>
<p>As more features will be added, the Employee interface will inevitably grow into an unmanageable, bloated entity</p>
<p>Ironically, <a href="./chapter_10.html">Chapter 10</a> talks about cohesion and single responsibility principle.
Yet here, to avoid a switch, he violates these core OOP principles.</p>
<div class="subtle-paragraph">
<b> Writing software is a balancing act </b> - it is a search for a solution in a system of contradictory constraints.
</div>
<p>By declaring <code>switch</code> fundamentally bad, Martin loses this balance. His solution increases complexity and couples unrelated concerns, trading one set of problems for another.</p>
<p>To properly separate concerns, we'd need to split <code>Employee</code> into focused interfaces like <code>Payable</code>, <code>Schedulable</code>, and <code>Transactionable</code>.
But to maintain polymorphism, we'd then need either three factories (repetition) or a factory of factories (over-engineering).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="use-descriptive-names"><a class="header" href="#use-descriptive-names">Use Descriptive Names</a></h2>
<div class="book-quote">
In Listing 3-7 I changed the name of our example function from testableHtml to SetupTeardownIncluder.render. This is a far better name because it better describes what the function does
</div>
<p>Nit-picking but <code>SetupTeardownIncluder.render</code> doesn't make much sense without reading the code. It's unclear why "Includer" should be rendering, and what does "rendering" mean for the "includer".</p>
<p>Using descriptive names is good. Using descriptions as names isn't.</p>
<div class="book-quote">
Don't be afraid to make a name long.
</div>
<p>I think you should. Between using cryptic acronyms and writing "essay as a name" there is a balance to be found.</p>
<p>There's scientific evidence that long words or word combinations increase both physical and mental effort when reading:</p>
<blockquote>
<p>"When we read, our eyes incessantly make rapid mechanical (i.e., not controlled by consciousness) movements, saccades. On average, their length is 7-9 letter spaces. At this time we do not receive new information."</p>
<p>"During fixation, we get information from the perceptual span. The size of this area is relatively small, in the case of alphabetic orthographies (for example, in European languages) it starts from the beginning of the fixed word, but no more than 3-4 letter spaces to the left of the fixation point, and extends to about 14-15 letter spaces to the right of this point (in total 17-19 spaces)."</p>
<center> 
  Figure 10. The typical pattern of eye movements while reading.
  <img src="https://optimal-codestyle.github.io/Velichkovskiy_reading.png" style=" -webkit-filter: invert(1); filter: invert(1);"/>
</center> 
<p>From: <a href="https://optimal-codestyle.github.io/">Optimal Code Style</a></p>
</blockquote>
<p>Names longer than <code>~15</code> characters become harder to process. Compare:</p>
<ul>
<li>
<p><code>PersistentItemRecordConfig</code></p>
</li>
<li>
<p><code>PersistentItemRec</code></p>
</li>
</ul>
<p>If youâ€™re not thinking about the meaning, the second name is visually and mentally easier to skim. The first name requires more effort to read and pronounce internally.</p>
<p>Long names also consume real estate of the screen and make code visually overwhelmiing.</p>
<pre><code class="language-java">PersistentItemRecordConfig persistentItemRecordConfig = new PersistentItemRecordConfig();
</code></pre>
<p>Â  Â  Â  vs Â  Â  Â </p>
<pre><code class="language-scala">val item = new PersistentItemRec()
</code></pre>
<p>Consider Bob Nystromâ€™s principles of good naming as a guide:</p>
<blockquote>
<p>A name has two goals:</p>
<ul>
<li>It needs to be clear: you need to know what the name refers to.</li>
<li>It needs to be precise: you need to know what it does not refer to.</li>
</ul>
<p>After a name has accomplished those goals, any additional characters are dead weight</p>
<ol>
<li>Omit words that are obvious given a variableâ€™s or parameterâ€™s type</li>
<li>Omit words that donâ€™t disambiguate the name</li>
<li>Omit words that are known from the surrounding context</li>
<li>Omit words that donâ€™t mean much of anything</li>
</ol>
<p>From <a href="https://journal.stuffwithstuff.com/2016/06/16/long-names-are-long/">Long Names Are Long</a></p>
</blockquote>
<br/>
<hr />
<h3 id="a-note-on-experience-levels"><a class="header" href="#a-note-on-experience-levels">A Note on Experience Levels</a></h3>
<p>I've recently read about <a href="https://buttondown.com/hillelwayne/archive/stroustrops-rule/">"Stroustrup's Rule"</a>.
The short version sounds like: <strong>"Beginners need explicit syntax, experts want terse syntax."</strong></p>
<blockquote>
<p>I see this as a special case of mental model development: when a feature is new to you, you don't have an internal mental model so need all of the explicit information you can get. Once you're familiar with it, explicit syntax is visual clutter and hinders how quickly you can parse out information.</p>
<p>(One example I like: which is more explicit, user_id or user_identifier? Which do experienced programmers prefer?)</p>
<p>From  <a href="https://buttondown.com/hillelwayne/archive/stroustrops-rule/">"Stroustrup's Rule" by  Hillel Wayne</a></p>
</blockquote>
<p>That is a good insight. <br/> And yet it is more appropriate to put the information required for "begginers" (those who are unfamiliar with a code base) into comments.
This way "experts" don't need to suffer from visual clutter.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="function-arguments"><a class="header" href="#function-arguments">Function Arguments</a></h2>
<div class="book-quote">
The ideal number of arguments for a function is zero (niladic). <br/>
Next comes one (monadic), followed closely by two (dyadic). <br/>
Three arguments (triadic) should be avoided where possible. <br/>
More than three (polyadic) requires very special justificationâ€”and then shouldn't be used anyway.
</div>
<p>I think Robert Martin gets the most amount of hate for this one.</p>
<div style="text-align:center"><a target="_blank" href="https://x.com/mariofusco/status/1596791273431928832"><img src="./images/fusco_bob.png" width="50%"/></a></div>
<p>The main problem with Martin's advice: it presents itself as "less is better" but handwaves all the downsides of the particular application.
He ignores trade-offs and side effects.</p>
<ul>
<li>"Smaller methods are better", but the increased amount of methods? Nah, you'll be fine.</li>
<li>"Less arguments for a function is better", but the increased scope of mutable state? Nah, you'll be fine</li>
<li>"Compression is better", but the bulging discs? Nah, you'll be fine.</li>
</ul>
<p>One particularly odd suggestion is to "simplify" by moving arguments into instance state:</p>
<div class="book-quote">
Arguments are hard. They take a lot of conceptual power. That's why I got rid of almost all of them from the example. 
Consider, for instance, the <code>StringBuffer</code> in the example. We could have passed it around as an argument rather than making it an instance variable, 
but then our readers would have had to interpret it each time they saw it. 
When you are reading the story told by the module, <code>includeSetupPage()</code> is easier to understand than <code>includeSetupPageInto(newPageContent)</code>
</div>
<p>This doesn't eliminate complexity - it relocates it.
But worse: moving parameters to fields increases size and the scope of the mutable state of the application. This sacrifices global complexity to reduce local one.
Tracking shared mutable state in multi-threaded environments is far harder than understanding function arguments.</p>
<div class="book-quote">
Arguments are even harder from a testing point of view. Imagine the difficulty of writing all the test cases to ensure that all the various combinations of arguments work properly. If there are no arguments, this is trivial.
</div>
<p>But this just shifts the burden. Method calls become simpler, but setting up test instances and tracking state becomes harder. Not a winning trade.</p>
<p>Ironically, functional programming exists specifically to limit mutable state, recognizing its cognitive cost. Martin clearly wasn't a fan at the time of writing Clean Code.</p>
<div class="book-quote">
One input argument is the next best thing to no arguments. SetupTeardownIncluder.render(pageData) is pretty easy to understand. 
Clearly we are going to render the data in the pageData object.
</div>
<p>Beating the same dead horse: <code>render(pageData)</code> might be easy to understand. <code>SetupTeardownIncluder.render(pageData)</code> still doesn't make sense.</p>
<h2 id="flag-arguments"><a class="header" href="#flag-arguments">Flag Arguments</a></h2>
<div class="book-quote">
"Flag arguments are ugly. Passing a boolean into a function is a truly terrible practice. It immediately complicates the signature of the method, 
loudly proclaiming that this function does more than one thing. It does one thing if the flag is true and another if the flag is false!"
</div>
<p>Martinâ€™s critique of flag arguments is front-loaded with emotion, but is it valid?
Adding boolean or any parameter is indeed a complication. Since <code>boolean</code> can accept 2 states, speaking more formaly adding boolean is doubling the domain space of the function.</p>
<p>Adding a boolean parameter to a function that already has 2 booleans will bring domain space from 4 to 8, this might be significant.
But adding boolean argument to a function that had none before would not kick complexity level into "unmanagable" territorry. It might be a tolerable increase.</p>
<div class="book-quote">
"Still, the method call render(true) is just plain confusing to a poor reader. Mousing over the call and seeing render(boolean isSuite) helps a little, but not that much. 
We should have split the function into two: renderForSuite() and renderForSingleTest()."
</div>
<p>While <code>render(true)</code> is indeed unclear on a caller side, modern programming languages offer solutions, such as named parameters:</p>
<pre><code class="language-python">render(asSuite = true)   # costs nothing in runtime
</code></pre>
<p>The deeper problem with <code>render(true)</code> is so-called <a href="https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/">boolean blindness</a></p>
<div class="subtle-paragraph">
"The problem is computing the bit in the first place. Having done so, you have blinded yourself by reducing the information you have at hand to a bit, 
and then trying to recover that information later by remembering the provenance of that bit."
<p>from <a href="https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/">Boolean Blindness</a></p>
</div>
<p>A better solution: Use enums to preserve semantic meaning:</p>
<pre><code class="language-java">enum ExcutionUnit { 
    SingleTest, 
    Suite 
} 

//...
public String renderAs(ExecutionUnit executionUnit) { ... }

// ------

//calling side:
renderAs(ExeuctionUnit.Suite);

</code></pre>
<p>It's unclear if Robert Martin <a href="./chapter_33.html">likes enums</a>.</p>
<p>The inherit unavoidable complexity is that tests can have 2 execution types: as a single test or as a part of a suite.
Splitting the <code>render</code> function "into two: renderForSuite() and renderForSingleTest()" does not reduce it. (neither does using boolean or enum)
It is still 2 types of execution.
There will be place in code that would have to take a decision and select one of the branches.<br/> Please do not create Abstract Factory for every boolean in your code.</p>
<h2 id="verbs-and-keywords"><a class="header" href="#verbs-and-keywords">Verbs and Keywords</a></h2>
<div class="book-quote">
"This last is an example of the keyword form of a function name. Using this form we encode the names of the arguments into the function name. 
<p>For example, assertEquals might be better written as <pre><code>assertExpectedEqualsActual(expected, actual)</code></pre>
This strongly mitigates the problem of having to remember the ordering of the arguments."</p>
</div>
<p>The suggestion to encode order of parameters in the name is not scalable -
it works in isolation, but would degrate quickly with real API when you need to do all kind of assertions:</p>
<ul>
<li><code>assertExpectesIsGreaterOrEqualsThanActual</code></li>
<li><code>assertActualContainsAllTheSameElementsAsExpected</code></li>
</ul>
<p>The best solution java can offer is fluent API: <a href="https://github.com/assertj/assertj">AssertJ</a></p>
<pre><code class="language-java">assertThat(frodo.getName()).isEqualTo("Frodo");
</code></pre>
<p>Outside java, this problem has other solutions:</p>
<ol>
<li>Named parameters - In languages like Python, named parameters eliminate ambiguity:</li>
</ol>
<pre><code class="language-python">assertEquals(expected = something, actual = actual)
</code></pre>
<ol start="2">
<li>Macros - In Rust, macros like assert_eq! automatically capture and display argument details, making order irrelevant:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_string_eq() {
    let expected = String::from("hello");
    let actual = String::from("world");
    
    assert_eq!(expected, actual);
    // Error message:

    // thread 'test_string_eq' panicked at:
    // assertion `left == right` failed
    //   left: "hello"
    //  right: "world"
    //   at src/main.rs:17:5
}

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="have-no-side-effects"><a class="header" href="#have-no-side-effects">Have No Side Effects</a></h2>
<p>Clean Code introduces side effects in a somewhat casual terms:</p>
<div class="book-quote">
"Side effects are lies. Your function promises to do one thing, but it also does other hidden things. 
Sometimes it will make unexpected changes to the variables of its own class. 
Sometimes it will make them to the parameters passed into the function or to system globals. 
In either case they are devious and damaging mistruths that often result in strange temporal couplings and order dependencies."
</div>
<p>To make it more formal: a side effect is any operation that:</p>
<ul>
<li>Modifies state outside the function's scope</li>
<li>Interacts with the external world (I/O, network, database)</li>
<li>Relies on non-deterministic behavior (e.g., random number generation, system clock)</li>
<li>Throws exception (which can alter the program's control flow in unexpected ways)</li>
</ul>
<p>Pure functionsâ€”those without side effectsâ€”are easier to reason about, test, and reuse.
Like mathematical functions, they produce the same outputs given the same inputs, with no hidden interactions.</p>
<p>Martin's example misses critical issues:</p>
<div class="book-quote">
"Consider, for example, the seemingly innocuous function in Listing 3-6. This function uses a standard algorithm to match a userName to a password. 
It returns true if they match and false if anything goes wrong. But it also has a side effect. Can you spot it?"
<pre><code class="language-java">
public class UserValidator {
    private Cryptographer cryptographer;

    public boolean checkPassword(String userName, String password) {
        User user = UserGateway.findByName(userName);
        if (user != User.NULL) {
            String codedPhrase = user.getPhraseEncodedByPassword();
            String phrase = cryptographer.decrypt(codedPhrase, password);
            if ("Valid Password".equals(phrase)) {
                Session.initialize();
                return true;
            }
        }
        return false;
    }
}
</code></pre>
<p>"The side effect is the call to Session.initialize(), of course. The checkPassword function, by its name, says that it checks the password."</p>
</div>
<p>He focuses on Session.initialize() as the side effect, suggesting a rename to checkPasswordAndInitializeSession. But this misses deeper problems:</p>
<ol>
<li><code>UserGateway.findByName(userName)</code> is likely a database call - another side effect. This creates temporal coupling: authentication fails if the database is unavailable.</li>
<li><code>UserGateway</code> is a singleton - a global implicit dependency.</li>
</ol>
<p>This illustrates why formal understanding of side effects matters.</p>
<p>It also reveals a contradiction: Martin's advice to move <a href="./chapter_35.html">input arguments</a> to object fields creates side effects by definition - methods must mutate shared state.</p>
<p>In rewrite suggestion from <a href="./chapter_2.html">chapter 2</a>, all new methods have a side effect - they mutate fields - Modify "state outside the function's scope":</p>
<div class="code-comparison">
    <div class="code-column" style="flex:0">
        <div class="code-column-title">Original Code: </div>
        <pre class="ignore"><code class="language-java">private void printGuessStatistics(char candidate, 
                                  int count) {   
    String number;
    String verb;
    String pluralModifier;
    if (count == 0) {
        number = "no";
        verb = "are";
        pluralModifier = "s";
    } else if (count == 1) {
        number = "1";
        verb = "is";
        pluralModifier = "";
    } else {
        number = Integer.toString(count);
        verb = "are";
        pluralModifier = "s";
    }
    String guessMessage = String.format(
        "There %s %s %s%s", verb, number, 
        candidate, pluralModifier
    );
    <span class="code-comment-trigger">â–º</span><span class="reviewable-line">print(guessMessage);<span class="code-comment">Interracts with the outside world - prints to STD-IO</span></span>
    &nbsp;
    &nbsp;
}</code></pre>
    </div>
    <div class="code-column">
        <div class="code-column-title">Proposed rewrite:</div>
        <pre class="ignore"><code class="language-java">public class GuessStatisticsMessage {
    private String number;
    private String verb;
    private String pluralModifier;
&nbsp; 
    public String make(char candidate, int count) {
        <span class="code-comment-trigger">â–º</span><span class="reviewable-line">createPluralDependentMessageParts(count);<span class="code-comment">Calling a function with side effects spreads those effects to the caller</span></span>
        return String.format(
                "There %s %s %s%s", 
                verb, number, candidate, pluralModifier );
    }
&nbsp; 
    private void createPluralDependentMessageParts(int count) {
        if (count == 0) {
            <span class="code-comment-trigger">â–º</span><span class="reviewable-line">thereAreNoLetters();<span class="code-comment">Calling a function with side effects spreads those effects to the caller</span></span>
        } else if (count == 1) {
            <span class="code-comment-trigger">â–º</span><span class="reviewable-line">thereIsOneLetter();<span class="code-comment">Calling a function with side effects spreads those effects to the caller</span></span>
        } else {
            <span class="code-comment-trigger">â–º</span><span class="reviewable-line">thereAreManyLetters();<span class="code-comment">Calling a function with side effects spreads those effects to the caller</span></span>
        }
    }
&nbsp; 
    private void thereAreManyLetters(int count) {
        <span class="code-comment-trigger">â–º</span><span class="reviewable-line">number = Integer.toString(count);<span class="code-comment">Modifies state outside function scope</span></span>
        <span class="code-comment-trigger">â–º</span><span class="reviewable-line">verb = "are";<span class="code-comment">Modifies state outside function scope</span></span>
        <span class="code-comment-trigger">â–º</span><span class="reviewable-line">pluralModifier = "s";<span class="code-comment">Modifies state outside function scope</span></span>
    }
&nbsp; 
    private void thereIsOneLetter() {
        <span class="code-comment-trigger">â–º</span><span class="reviewable-line">number = "1";<span class="code-comment">Modifies state outside function scope</span></span>
        <span class="code-comment-trigger">â–º</span><span class="reviewable-line">verb = "is";<span class="code-comment">Modifies state outside function scope</span></span>
        <span class="code-comment-trigger">â–º</span><span class="reviewable-line">pluralModifier = "";<span class="code-comment">Modifies state outside function scope</span></span>
    }
&nbsp; 
    private void thereAreNoLetters() {
        <span class="code-comment-trigger">â–º</span><span class="reviewable-line">number = "no";<span class="code-comment">Modifies state outside function scope</span></span>
        <span class="code-comment-trigger">â–º</span><span class="reviewable-line">verb = "are";<span class="code-comment">Modifies state outside function scope</span></span>
        <span class="code-comment-trigger">â–º</span><span class="reviewable-line">pluralModifier = "s";<span class="code-comment">Modifies state outside function scope</span></span>
    }
}</code></pre>
    </div>
</div>
<p>The "improved" version spreads side effects everywhere:</p>
<ul>
<li>Every helper method mutates shared state</li>
<li>Calling methods with side effects propagates those effects upward</li>
<li>The entire class becomes a web of interdependent state changes</li>
</ul>
<p>This perfectly demonstrates why moving local variables to class fields often makes code harder to reason about, not easier.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="prefer-exceptions-to-returning-error-codes"><a class="header" href="#prefer-exceptions-to-returning-error-codes">Prefer Exceptions to Returning Error Codes</a></h2>
<p>To illustrate the guide-line he starts with an example:</p>
<div class="book-quote">
<pre><code class="language-java">
if (deletePage(page) == E_OK) {
    if (registry.deleteReference(page.name) == E_OK) {
        if (configKeys.deleteKey(page.name.makeKey()) == E_OK){
            logger.log("page deleted");
        } else {
            logger.log("configKey not deleted");
        }
    } else {
        logger.log("deleteReference from registry failed");
    }
} else {
    logger.log("delete failed");
    return E_ERROR;
}
</code></pre>
</div>
<p>Lets do a quick de-tour...</p>
<div class="big-emphasis">
    <p className="text-4xl font-bold text-teal-400 animate-pulse">
        THESE ðŸ‘ ARE ðŸ‘ TERRIBLE ðŸ‘ LOG ðŸ‘ MESSAGES!
    </p>
</div>
<p>They lack any context to the degree of being useless.</p>
<p>Imagine debugging production issue at 3am and seeing:</p>
<pre><code>2024-01-01T02:45:00 - delete failed
</code></pre>
<p>Well, thank you dear sir cleancoder. Now I have everything I need!</p>
<p>Never write logging like this. Even as a joke. Good log messages must include:</p>
<ul>
<li>The operation was being performed</li>
<li>Input parameters</li>
<li>Outcome or reason for failure</li>
</ul>
<p>Also error handling must be cosistent!
The provided code returns E_ERROR only in case if first failurer, errors to <code>deleteReference</code> and <code>deleteKey</code> are essentialy ignored.</p>
<p>Martin's "improved" version:</p>
<div class="book-quote">
<pre><code class="language-java">
try {
    deletePage(page);
    registry.deleteReference(page.name);
    configKeys.deleteKey(page.name.makeKey());
} catch (Exception e) {
    logger.log(e.getMessage());
}
</code></pre>
</div>
<div class="big-emphasis">
    <p className="text-4xl font-bold text-teal-400 animate-pulse">
        ALWAYS ðŸ‘ LOG ðŸ‘ STACK-TRACES!
    </p>
</div>
<p>At minimum:</p>
<pre><code class="language-java">logger.log(e.getMessage(), e);
</code></pre>
<p>or better yet:</p>
<pre><code class="language-java">logger.log("Got an error while deleting page: " + page, e);
</code></pre>
<p>This includes operation context, parameters, and stack traces <span style="font-size:2rem"> ðŸ˜ </span></p>
<p>But notice: the refactored version silently swallows ALL errors.</p>
<pre><code class="language-java">public void delete(Page page) {
    try {
        deletePage(page);
        registry.deleteReference(page.name);
        configKeys.deleteKey(page.name.makeKey());
    } catch (Exception e) {
        logger.error("Got an error while deleting page: " + page, e);
    }
}
</code></pre>
<p>The operation always "succeeds", even when it fails. Almost always this is a design mistake.</p>
<p>Best Practices for Exception Handling:</p>
<ul>
<li><strong>Let Exceptions Propagate When Appropriate</strong>: If the code catching the exception doesnâ€™t know how to handle it, it should let it propagate to a higher layer</li>
<li><strong>Log-and-Throw When Necessary</strong>: If local context (e.g., the page object) is important for debugging and isnâ€™t available in upper layers, itâ€™s reasonable to log the error before re-throwing:</li>
</ul>
<pre><code class="language-java">public void delete(Page page) thows Exception {
    try {
        deletePage(page);
        registry.deleteReference(page.name);
        configKeys.deleteKey(page.name.makeKey());
    } catch (Exception e) {
        logger.error("Got an error while deleting page: " + page, e);
        throw e;
    }
}
</code></pre>
<h3 id="extract-trycatch-blocks"><a class="header" href="#extract-trycatch-blocks">Extract Try/Catch Blocks</a></h3>
<p>Martin suggests splitting the delete method:</p>
<div class="code-comparison">
    <div class="code-column" style="flex:0">
        <div class="code-column-title">Original Code: </div>
        <pre class="ignore"><code class="language-java">public void delete(Page page) {
  try {
    deletePage(page);
    registry.deleteReference(page.name);
    configKeys.deleteKey(page.name.makeKey());
  } catch (Exception e) {
    logger.log(e.getMessage());
  }
}</code></pre>
    </div>
    <div class="code-column">
        <div class="code-column-title">Proposed rewrite:</div>
        <pre class="ignore"><code class="language-java">public void delete(Page page) {
  try {
    deletePageAndAllReferences(page);
  } catch (Exception e) {
    logError(e);
  }
}
&nbsp;
private void deletePageAndAllReferences(Page page) throws Exception {
  deletePage(page);
  registry.deleteReference(page.name);
  configKeys.deleteKey(page.name.makeKey());
}
&nbsp;
private void logError(Exception e) {
  logger.log(e.getMessage());
}</code></pre>
    </div>
</div>
<p>He proposed to rewrite 1 method with 8 lines of code into 3 methods with 16 lines of code (including whitespacing).
This is just a code bloat.</p>
<p>Looking at original <code>delete</code>: you could immidiately grasp that it was executing 3 deletions, that it is silencing the errors and that the logging was done incorrectly.</p>
<p>All this information is gone now from new <code>delete</code> method:</p>
<pre><code class="language-java">public void delete(Page page) {
  try {
    deletePageAndAllReferences(page);
  } catch (Exception e) {
    logError(e);
  }
}
</code></pre>
<p>Ok, maybe error silencing is stil noteceable.</p>
<p><code>deletePageAndAllReferences</code> clearly is not doing 1 thing only, is it?<br/>
I think the name is not descriptive enough, it should be <code>deletePageAndAllReferencesAndPageKey</code>. <em><strong>/s</strong></em></p>
<p>Clumsy names is one of the smells indicating that something is wrong with the model or with an abstraction.<br/>
I think in this case, the code screams: <strong>"Don't butcher me, uncle Bob. I should exist and prosper as a single piece.
Don't create useless methods just satisfy arbitary rule that doesn't have any value"</strong></p>
<blockquote>
<p>"If it's hard to find a simple name for a variable or method that creates a clear image of the underlying object, that's a hint that the underlying object may not have a clean design."</p>
<p>from <a href="https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201">Philosophy Of Software Design</a></p>
</blockquote>
<p>The extracted logging method makes things worse:</p>
<pre><code class="language-java">private void logError(Exception e) {
    logger.log(e.getMessage());
}
</code></pre>
<p>Is an example that bad abstractions can do more harm than good. It fails to capture meaningful context or stack traces.
The more this helper being used in the app, the harder it will be to manage this application.</p>
<hr />
<h3 id="error-handling-approaches"><a class="header" href="#error-handling-approaches">Error Handling Approaches</a></h3>
<p>Ok. Now lets talk about exception vs error codes.</p>
<p>Code needs a channel to communicate errors and that channel needs to be different from channel of communicating normal results.
Martin have avoided this discussion by using methods that have nothing to communicate via normal channel.</p>
<p>Javaâ€™s exception handling is powerful and widely supported, offering features like:</p>
<ul>
<li>Stack traces for debugging</li>
<li>Causality chaining for error contexts</li>
<li>Compile-time enforcement of error handling (checked exceptions)</li>
</ul>
<hr />
<p>Modern languages like Rust and Scala favor representing errors as values.
This approach avoids the implicit flow control of exceptions by making errors explicit in function signatures.</p>
<p>For example, in Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn delete_page(page: &amp;Page) -&gt; Result&lt;(), Error&gt; {
    // Perform deletion logic
}
<span class="boring">}</span></code></pre></pre>
<h3 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h3>
<p>Using exceptions instead of error codes is generally a good practice, but itâ€™s not a silver bullet. Effective error handling requires thoughtful design:</p>
<ul>
<li>Use exceptions to propagate errors, but donâ€™t swallow them silently.</li>
<li>Log meaningful context along with stack traces.</li>
<li>Avoid refactors that bloat the code or obscure key operations.</li>
<li>Consider whether exceptions or an error-as-value approach best fits your use case.</li>
</ul>
<p>Error handling isnâ€™t just about avoiding failureâ€”itâ€™s about making failure clear, actionable, and easy to debug.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="how-do-you-write-functions-like-this"><a class="header" href="#how-do-you-write-functions-like-this">How Do You Write Functions Like This?</a></h2>
<div class="book-quote">
"When I write functions, they come out long and complicated. They have lots of indenting and nested loops. They have long argument lists. 
The names are arbitrary, and there is duplicated code."
<p>"So then I massage and refine that code, splitting out functions, changing names, eliminating duplication. I shrink the methods and reorder them. Sometimes I break out whole classes, all the while keeping the tests passing.
In the end, I wind up with functions that follow the rules I've laid down in this chapter. I don't write them that way to start. I don't think anyone could."</p>
</div>
<p>What's Martin is advocating is bottom-up approach to software development: first make it work, then make it beautiful( = "clean", in Matrins worldview).</p>
<p>But this is not the only way to design software!</p>
<p>In my experience, top-down design often produces more elegant solutions:</p>
<ol>
<li>Start by imagining how you want the code to look like</li>
<li>Sketch it in pseudocode</li>
<li>Gradually fill in the implementation details, making adjustments as needed while preserving the original design</li>
</ol>
<h3 id="a-concrete-example"><a class="header" href="#a-concrete-example">A Concrete Example</a></h3>
<p>One of my biggest pet peeves is that <a href="https://www.hillelwayne.com/post/decision-tables/">Decision Tables</a> are underused in programming. They make complex logic immediately obvious and provide a perfect overview of the problem.</p>
<pre><code>PAYMENT METHOD    |   DISCOUNT CODE   |    TAX STATUS    |    PRICE
--------------------------------------------------------------------
PayPal            |    CLEANCODE      |     NONEXEMPT    |    8.99
CreditCard        |      N/A          |     NONEXEMPT    |    9.99
</code></pre>
<p>Standard JUnit tests lose this clarity:</p>
<pre><code class="language-java">assertEquals(
    priceService.calcuate(new Criteria()
        .paymentMethod(Payment.PayPal)
        .discountCode("CLEANCODE")
        .taxStatus(Tax.NonExempt)
   ),
    new BigDecimal("8.99")
);


assertEquals(
    priceService.calcuate(new Criteria()
        .paymentMethod(Payment.CreditCatd)
        .discountCode("")
        .taxStatus(Tax.NonExempt)
    ),
    new BigDecimal("9.99")
);
</code></pre>
<p>No amount of refactoring will restore the original table-like structure.</p>
<p>But if you start with a top-down approach, you can decide upfront that you want your test to look like a decision table. That might lead you to write code like this:</p>
<pre><code class="language-java">executeTests(
    "PAYMENT METHOD     |   DISCOUNT CODE   |    TAX STATUS    |    PRICE  \n" +
    "----------------------------------------------------------------------\n" + 
    " PayPal            |    CLEANCODE      |     NONEXEMPT    |    8.99   \n" + 
    " CreditCard        |      N/A          |     NONEXEMPT    |    9.99   \n" 
)

</code></pre>
<p>Now, the challenge becomes figuring out how to implement a parser and interpreter for executeTests.</p>
<p>Or you might take an approach that doesn't require parsing and design an internal DSL that still looks like a table:</p>
<pre><code class="language-java">testTable()
    .header (
    //------------------------------------------------------------------------------------
           PAYMENT_METHOD     , DISCOUNT_CODE, TAX_STATUS     ,     PRICE              ) 
    //------------------------------------------------------------------------------------
    .row( Payment.PayPal      , "CLEANCODE"  , Tax.NonExempt  , new BigDecimal("8.99") ),
    .row( Payment.CreditCard  , ""           , Tax.NonExempt  , new BigDecimal("9.99") )
    //------------------------------------------------------------------------------------
    .executeTests()
</code></pre>
<p>Yes, these approaches require more upfront work. That's not the point.</p>
<p>The key insight: top-down design lets you control code structure from the start. You build supporting infrastructure to achieve your vision.</p>
<p>In contrast, starting with a messy, working solution and then refining it into something cleaner is more of a discovery process.
When your refactoring toolkit consists mainly of extraction techniques (as Martin suggests), you often end up with suboptimal results.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-4-comments"><a class="header" href="#chapter-4-comments">Chapter 4: Comments</a></h1>
<p>The chapter about comments is not inherently bad - it contains enough caveats and examples of bad vs good comments. However, Martin poisons the well from the start:</p>
<div class="book-quote">
Comments are not like Schindler's List. They are not "pure good." Indeed, comments are, at best, a necessary evil. If our programming languages were expressive enough, or if we had the talent to subtly wield those languages to express our intent, we would not need comments very muchâ€”perhaps not at all.
<p>The proper use of comments is to compensate for our failure to express ourself in code. Note that I used the word failure. I meant it. Comments are always failures. We must have them because we cannot always figure out how to express ourselves without them, but their use is not a cause for celebration.</p>
<p>So when you find yourself in a position where you need to write a comment, think it through and see whether there isn't some way to turn the tables and express yourself in code. Every time you express yourself in code, you should pat yourself on the back. Every time you write a comment, you should grimace and feel the failure of your ability of expression.</p>
</div>
<p>This might be the book's most damaging idea: comments are failure to write good code.</p>
<p>I believe this is the main takeaway that developers get out the chapter and the book.
Declaring "comments are failure" has led developers to avoid a crucial tool for design, abstraction, and documentation.
It's contributed to a culture where comments are undervalued and often ignored (notice how IDEs gray them out by default).</p>
<p>Martin implicitly promotes "self-documenting code." But code alone can never provide all context.
Even perfect code can only show what's there - not what's deliberately excluded or what was considered and rejected.</p>
<p>This anti-comment position drives verbose, over-descriptive naming:</p>
<pre><code class="language-java">private static int smallestOddNthMultipleNotLessThanCandidate(int candidate, int n) { }
</code></pre>
<p>Is <code>smallestOddNthMultipleNotLessThanCandidate</code> really a name or just inlined comment ?</p>
<p>Names are part of the code, but theyâ€™re just one step removed from comments: the compiler doesnâ€™t check or enforce their semantic meaning,
so they can easily fall out of sync â€” just like comments.</p>
<pre><code class="language-java">private static int smallestOddNthMultipleNotLessThanCandidate(int candidate, int n) { 
    return Integer.MAX_VALUE; // I lied â”Œâˆ©â”(â—£_â—¢)â”Œâˆ©â”
}
</code></pre>
<h3 id="recommended-reading"><a class="header" href="#recommended-reading">Recommended reading</a></h3>
<ul>
<li><a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">"Philosophy Of Software Design"</a>
<ul>
<li>Chapter 12. Why Write Comments? The Four Excuses</li>
<li>Chapter 13. Comments Should Describe Things that Arenâ€™t Obvious from the Code</li>
<li>Chapter 15. Write The Comments First</li>
</ul>
</li>
<li>Hillel Wayne's "Computer Things" blog:
<ul>
<li><a href="https://buttondown.email/hillelwayne/archive/the-myth-of-self-documenting-code/">The myth of self-documenting code</a></li>
<li><a href="https://buttondown.email/hillelwayne/archive/comment-the-why-and-the-what/">Comments the why and the what</a></li>
<li><a href="https://buttondown.email/hillelwayne/archive/why-not-comments/">Why Not comments</a></li>
</ul>
</li>
</ul>
<h2 id="example-prime-number-generator"><a class="header" href="#example-prime-number-generator">Example: Prime Number Generator</a></h2>
<p>Here's the original code:</p>
<pre><code class="language-java">/**
 * This class Generates prime numbers up to a user specified
 * maximum.  The algorithm used is the Sieve of Eratosthenes.
 * &lt;p&gt;
 * Eratosthenes of Cyrene, b. c. 276 BC, Cyrene, Libya --
 * d. c. 194, Alexandria.  The first man to calculate the
 * circumference of the Earth.  Also known for working on
 * calendars with leap years and ran the library at Alexandria.
 * &lt;p&gt;
 * The algorithm is quite simple.  Given an array of integers
 * starting at 2.  Cross out all multiples of 2.  Find the next
 * uncrossed integer, and cross out all of its multiples.
 * Repeat until you have passed the square root of the maximum
 * value.
 *
 * @author Alphonse
 * @version 13 Feb 2002 atp
 */
 public class GeneratePrimes     
     /**
     * @param maxValue is the generation limit.
     */
     public static int[] generatePrimes(int maxValue) {
     if (maxValue &gt;= 2) // the only valid case
     {
         // declarations
         int s = maxValue + 1; // size of array
         boolean[] f = new boolean[s];
         int i;
         // initialize array to true.
         for (i = 0; i &lt; s; i++)
             f[i] = true;

         // get rid of known non-primes
         f[0] = f[1] = false;

         // sieve
         int j;
         for (i = 2; i &lt; Math.sqrt(s) + 1; i++) {
             if (f[i]) // if i is uncrossed, cross its multiples.
             {
                 for (j = 2 * i; j &lt; s; j += i)
                     f[j] = false; // multiple is not prime
             }
         }

         // how many primes are there?
         int count = 0;
         for (i = 0; i &lt; s; i++) {
             if (f[i])
                 count++; // bump count.
         }

         int[] primes = new int[count];

         // move the primes into the result
         for (i = 0, j = 0; i &lt; s; i++) {
             if (f[i])  // if prime
                 primes[j++] = i;
         }

         return primes;  // return the primes
     } else // maxValue &lt; 2
         return new int[0]; // return null array if bad input.
     }

</code></pre>
<p>I can grant that this is pretty convoluted code, but honestly I'm not sure if it was written this way or it was intentionally obfuscated.</p>
<p>The good parts: the messines of the code is contained in a single place and API is safe and clear.</p>
<p>Comment about the library of Alexandria is cute, I would also add a link to the Wikipedia page.</p>
<p>The Martins refactoring:</p>
<pre class="ignore"><code class="language-java">
/**
 * This class Generates prime numbers up to a user specified
 * maximum.  The algorithm used is the Sieve of Eratosthenes.
 * Given an array of integers starting at 2:
 * Find the first uncrossed integer, and cross out all its
 * multiples.  Repeat until there are no more multiples
 * in the array.
 */
public class PrimeGenerator {
    <span class="code-comment-trigger">â–º</span><span class="reviewable-line">private static boolean[] crossedOut;<span class="code-comment">GLOBAL <b>MUTABLE</b> STATE!<br/> This is intermediate state</span></span>
    <span class="code-comment-trigger">â–º</span><span class="reviewable-line">private static int[] result<span class="code-comment">GLOBAL <b>MUTABLE</b> STATE!<br/> This is final state of computation</span></span>

    public static int[] generatePrimes(int maxValue) {
        if (maxValue < 2)
            return new int[0];
        else {
            uncrossIntegersUpTo(maxValue);
            crossOutMultiples();
            putUncrossedIntegersIntoResult();
            return result;
        }
    }

    private static void uncrossIntegersUpTo(int maxValue) {
        crossedOut = new boolean[maxValue + 1];
        for (int i = 2; i < crossedOut.length; i++)
            crossedOut[i] = false;
    }

    private static void crossOutMultiples() {
        int limit = determineIterationLimit();
        for (int i = 2; i <= limit; i++)
            if (notCrossed(i))
                crossOutMultiplesOf(i);
    }

    private static int determineIterationLimit() {
        // Every multiple in the array has a prime factor that
        // is less than or equal to the root of the array size,
        // so we don't have to cross out multiples of numbers
        // larger than that root.
        <span class="code-comment-trigger">â–º</span><span class="reviewable-line">double iterationLimit = Math.sqrt(crossedOut.length);<span class="code-comment">Nitpick, but why is this extraction needed? </span></span>
        return (int) iterationLimit;
    }

    private static void crossOutMultiplesOf(int i) {
        for (int multiple = 2*i;
             multiple < crossedOut.length;
             multiple += i)
            crossedOut[multiple] = true;
    }

    private static boolean notCrossed(int i) {
        return crossedOut[i] == false;
    }

    private static void putUncrossedIntegersIntoResult() {
        result = new int[numberOfUncrossedIntegers()];
        for (int j = 0, i = 2; i < crossedOut.length; i++)
            if (notCrossed(i))
                result[j++] = i;
    }

    private static int numberOfUncrossedIntegers() {
        int count = 0;
        for (int i = 2; i < crossedOut.length; i++)
            if (notCrossed(i))
                count++;

        return count;
    }
}
</code></pre>
<p>Right off the bat: The refactoring introduced serious thread-safety issues by using <strong>static global mutable state</strong> (<code>crossedOut</code> and <code>result</code> - static fields)</p>
<p>The rule of thumb: if you see mutable static variables - <strong>RUN!</strong></p>
<p>This code can not be used as is in multi-threaded environment.
You will <em>have to</em> remedy this by using <strong>global</strong> lock, so that at most one thread in the application can be computing this.</p>
<p>Is there reason to introduce this scalability limit and take performance hit? No.<br/> This is self-inflicted pain. There is 0 reasons for this design.</p>
<p>Second: are those small methods really necessary?</p>
<pre><code class="language-java">private static boolean notCrossed(int i) {
    return crossedOut[i] == false;
}
</code></pre>
<p>Compare: <code class="language-java">if (notCrossed(i))</code> Â  <strong>vs</strong> Â  <code class="language-java">if (crossedOut[i] == false)</code>. Is the first option really more readable?
If anything, now he have polluted the domain with semi-similar words:</p>
<ul>
<li>not crossed</li>
<li>crossed out</li>
<li>uncrossed</li>
</ul>
<p>Is "notCrossed" same thing as "not crossedOut"? Is it same thing as "uncrossed"?
One would have to look into implementation of all those small methods to understand if there is a difference or not.</p>
<p>This exemplifies the problem with too many small entities: human working memory holds 4-7 objects. Flood it with pebbles, and you'll hit cognitive overload.
By excessive method extraction Martin introduced inconsistencies and confusion in terminlogy.</p>
<p>Lets remove obfuscation from the original method:</p>
<pre><code class="language-java">public class GeneratePrimes {
    public static int[] generatePrimes(int maxValue) {
        if (maxValue &lt; 2) {  // first two numbers are not prime
            return new int[0];
        }

        boolean[] crossedOut = new boolean[maxValue + 1];
        Arrays.fill(crossedOut, 2, crossedOut.length, Boolean.TRUE); // first two numbers are not prime

        // the algorithm
        for (int i = 2; i &lt; Math.sqrt(crossedOut.length) + 1; i++) {
            if (crossedOut[i]) {
                for (int j = 2 * i; j &lt; crossedOut.length; j += i)
                    crossedOut[j] = false; // multiple is not prime
            }
        }

        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; crossedOut.length; i++) {
            if (crossedOut[i]) result.add(i);
        }
        return result.toArray(new int[result.size()]);
    }
}
</code></pre>
<p>Does this look complicated?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formatting"><a class="header" href="#formatting">Formatting</a></h1>
<p>Formatting is fine. Don't try to replicate news papers in your code and you'll be fine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-6-objects-and-data-structures"><a class="header" href="#chapter-6-objects-and-data-structures">Chapter 6: Objects and Data Structures</a></h1>
<p>I donâ€™t think this chapter has aged poorly; rather, it seems to have been misaligned from the start with the common understanding of data structures,
the purpose of abstraction, and the principles of information hiding.</p>
<div class="book-quote">
<pre><code class="language-java">public interface Point {
    double getX();
    double getY();
    void setCartesian(double x, double y);
    double getR();
    double getTheta();
    void setPolar(double r, double theta);
}</code></pre>
The beautiful thing about Listing 6-2 is that there is no way you can tell whether the implementation is in rectangular or polar coordinates. It might be neither! And yet the interface still unmistakably represents a data structure.
</div>
<p>There is nothing beautiful about this interface. An interface of just getters and setters is usually a <em>design mistake</em>.
Interfaces should define <em>a contract of behavior</em>, not merely obfuscate the internal data structure.
They should provide <em>meaningful abstractions</em>, not just hide implementation details.</p>
<p>The fact that it's impossible to tell if this is about rectangular or polar coordinates is not true.
It's both and it forces all implementations to be both.</p>
<p>Here's a cleaner design:</p>
<pre><code class="language-java">sealed interface Point;
record Rectangular(double length, double width) implements Point { }
record Polar(double r, double theta) implements Point {};

public Rectangular convert(Polar polar) {...}
public Polar convert(Rectangular rectangular) {...}
</code></pre>
<p>Martin would say that "This exposes implementation"</p>
<p>But the thing is that there is no implementation to be exposed, the Point is put data and its shape is essential to its meaning.
In statically typed languages, explicitly communicating the shape of data through types is the goal.</p>
<p>Not every abstraction needs to hide its data structure - sometimes the data structure itself is the abstraction.</p>
<div class="book-quote">
Hiding implementation is not just a matter of putting a layer of functions between the variables. Hiding implementation is about abstractions!
</div>
<p>Exactly! But introducing unnecessary abstractions is over-engineering. As Edsger Dijkstra noted:</p>
<blockquote>
<p>"The purpose of abstraction is not to be vague, but to create a new semantic level in which one can be absolutely precise." - Dijkstra 1972</p>
</blockquote>
<p>Martin's Point interface adds vagueness, not precision. It combines two coordinate systems without clear purpose.
A good abstraction adds precision and reduces ambiguityâ€”not the other way around.</p>
<div class="book-quote">
Consider Listing 6-3 and Listing 6-4. The first uses concrete terms to communicate the fuel level of a vehicle, whereas the second does so with the abstraction of percentage.
<p>Listing 6-3 Concrete Vehicle</p>
<pre><code class="language-java">public interface Vehicle {
  double getFuelTankCapacityInGallons();
  double getGallonsOfGasoline();
}
</code></pre>
<p>Listing 6-4 Abstract Vehicle</p>
<pre><code class="language-java">public interface Vehicle {
  double getPercentFuelRemaining();
}
</code></pre>
<p>In both of the above cases the second option is preferable. We do not want to expose the details of our data. Rather we want to express our data in abstract terms.</p>
</div>
<p>This is not hiding "details of our data", this is data hiding!
Depending on the context, this might be good or bad. For example, with the second option, it becomes impossible to calculate the cost of filling the tank.
Are we designing for scammy car rentals? If so, then sure, hide the data.</p>
<p>The assumption that hiding data is always good is simply wrong.</p>
<p><strong>Ineffective abstraction</strong> occurs when essential knowledge is removed, or when non-essential knowledge is unnecessarily exposed - or both.</p>
<h1 id="dataobject-anti-symmetry"><a class="header" href="#dataobject-anti-symmetry">Data/Object Anti-Symmetry</a></h1>
<p>This chapter touches expression problem, without mentioning that this is the expression problem. It briefly mentions Visitor pattern as a solution for the problem.</p>
<p>So far so good.
However, Martin conflates dumb data objects with data structures.
Which is unfortunate cause the name "data structure" is reserved for objects that indeed have specialized structure for the data: lists, trees, stacks, etc.</p>
<p>Let's be precise about three types:</p>
<ul>
<li>Data objects (or Data transfer objects) - dumb containers for data</li>
<li>Stateless objects (or effectively stateless objects with dependencies) - behaviour only services</li>
<li>Stateful objects: Objects that encapsulate both state and behavior, often used for data structures.</li>
</ul>
<p>Modern design, even in Java, prefers separating stateless services from data objects. Stateful objects are mainly for true data structures.</p>
<p>In Martins terms:</p>
<ul>
<li>Data Structures = Dumb Objects</li>
<li>True Objects = Stateless and Stateful objects.</li>
</ul>
<p>He correctly criticizes hybrid objects (mixing data and behavior) - except for actual data structures. A Stack interface is legitimately hybrid:</p>
<pre><code class="language-java">interface Stack&lt;T&gt; {
   Optional&lt;T&gt; peek();
   Optional&lt;T&gt; pop(); 
   void push(T item); 
}
</code></pre>
<p>But it's a good one.</p>
<h1 id="law-of-demeter"><a class="header" href="#law-of-demeter">Law of Demeter</a></h1>
<div class="book-quote">
There is a well-known heuristic called the Law of Demeter2 that says a module should not know about the innards of the objects it manipulates. As we saw in the last section, objects hide their data and expose operations. This means that an object should not expose its internal structure through accessors because to do so is to expose, rather than to hide, its internal structure
</div>
<p>This law is from 1987. It might be a beneficial rule if the code base consists of mostly Hybrid objects.
Today's separation of stateless services from data objects makes this law less relevant.</p>
<p>Instead of the somewhat convoluted rules of the Law of Demeter, consider this:</p>
<ul>
<li><em>Service objects</em> should not expose their collaborators or dependencies.</li>
<li><em>Data objects</em> canâ€”and often shouldâ€”be open books.</li>
<li><em>Data structures</em> are more flexible, the exposure of internal details depends on the specific goals and design of the data structure.<br/>
(For example, an <a href="https://www.data-structures-in-practice.com/intrusive-linked-lists/">intrusive linked list</a> deliberately exposes internal pointers to optimize performance)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-7-error-handling"><a class="header" href="#chapter-7-error-handling">Chapter 7: Error Handling</a></h1>
<p>The chapter is written by <a href="https://www.amazon.com/dp/0131177052">Michael Feathers</a>.</p>
<p>I wish chapter has way more emphasis on how important error handling is.
A significant portion of software bugs and catastrophic failures caused by improper error handling.
As highlighted in a study by <a href="https://www.usenix.org/system/files/conference/osdi14/osdi14-paper-yuan.pdf">Ding Yuan et al. (2014 USENIX OSDI)</a>:</p>
<blockquote>
<p>We found the majority of catastrophic failures could easily have been prevented by performing simple testing on error handling code â€“ the last line of defense â€“ even without an understanding of the software design</p>
<p>from <a href="https://www.usenix.org/system/files/conference/osdi14/osdi14-paper-yuan.pdf">Simple Testing Can Prevent Most Critical Failures</a></p>
</blockquote>
<h1 id="use-exceptions-rather-than-return-codes"><a class="header" href="#use-exceptions-rather-than-return-codes">Use Exceptions Rather Than Return Codes</a></h1>
<p>This reiterates advice from <a href="./chapter_37.html">"Prefer Exceptions to Returning Error Codes"</a>, but provides an improved example with better logging practices:</p>
<pre><code class="language-java">public class DeviceController {
    public void sendShutDown() {
        DeviceHandle handle = getHandle(DEV1);
        // Check the state of the device
        if (handle != DeviceHandle.INVALID) {
            // Save the device status to the record field
            retrieveDeviceRecord(handle);
            // If not suspended, shut down
            if (record.getStatus() != DEVICE_SUSPENDED) {
                pauseDevice(handle);
                clearDeviceWorkQueue(handle);
                closeDevice(handle);
            } else {
                logger.log("Device suspended. Unable to shut down");
            }
        } else {
            logger.log("Invalid handle for: " + DEV1.toString());
        }
    }
}

// proposed to be rewritten to:

public class DeviceController {
//...
    public void sendShutDown() {
        try {
            tryToShutDown();
        } catch (DeviceShutDownError e) {
            logger.log(e);
        }
    }

    private void tryToShutDown() throws DeviceShutDownError {
        DeviceHandle handle = getHandle(DEV1);
        DeviceRecord record = retrieveDeviceRecord(handle);

        pauseDevice(handle);
        clearDeviceWorkQueue(handle);
        closeDevice(handle);
    }

    private DeviceHandle getHandle(DeviceID id) {
        //...
        throw new DeviceShutDownError("Invalid handle for: " + id.toString());
        //...
    }
//...
}
</code></pre>
<p>Why Logging Matters:</p>
<p>Proper logging is a cornerstone of effective error handling. It's not a minor point â€” it's what distinguishes maintainable software from unmanageable one.</p>
<p>The book lists down-sides of error codes:</p>
<ul>
<li>they clutter the call side, the client code needs to check for errors immediately</li>
<li>it's easy to forget to handle error values</li>
<li>logic is obscured by error handling</li>
</ul>
<p>All of this is true for typical java business app. But for critical systems, error handling should be built right into the main flow.</p>
<p>In languages like Go,  the "need to check immediately" point is considered to be a benefit - the error handling is somewhat enforced and is always expected to visible in code.</p>
<h2 id="use-unchecked-exceptions"><a class="header" href="#use-unchecked-exceptions">Use Unchecked Exceptions</a></h2>
<p>Unchecked exceptions had won.
In Java, checked exceptions have only gotten worse, especially since lambdas make them even more unpleasant source of clutter.</p>
<pre><code class="language-java">userIds.stream().map(dao::findById).collect(Collectors.toList())
</code></pre>
<p>vs</p>
<pre><code class="language-java">userIds.stream().map(id -&gt; {
    try {
        return dao.findById(id);
    } catch(SQLException e) {
        throw new RuntimeException(e);
    }
}).collect(Collectors.toList())
</code></pre>
<p>The former version was already verbose, but checked exceptions makes it truly eye-sore. (compare with scala version: <code>userIds.map(dao.findById)</code>)</p>
<p>However combination of</p>
<p><code>"do not use errors as return values" + "use unchecked exceptions"</code></p>
<p>means that error handling is pushed out compiler and typesystem control.
Errors and error handling <em>won't be</em> type safe and the compiler <em>would not</em> help checking this aspect of the code.</p>
<p>I don't agree with blank statement to always use unchecked exception.</p>
<p>Ideally we want to be able to tell if a function can fail or not:</p>
<pre><code class="language-java">public Long sum(List&lt;Long&gt; list);

public BigDecimal sumSalaries(List&lt;Long&gt; employeeIds) throws SQLException;
</code></pre>
<p>The big problem with checked exceptions is that they leak implementation details:</p>
<pre><code class="language-java">interface UserDAO {
    Optional&lt;User&gt; findById(String username) throws SQLException;
}
</code></pre>
<p>UserDAO is an abstraction that should hide persistance details. And switching storage engines should be transparent for the upper layers.
Plus, only DAO layer can make a decision based on SQLException level, upper layers most likely don't have enough context.</p>
<p>Enterprise grade solution is to have layered exceptions:</p>
<pre><code class="language-java">class DAOException extends Exception

interface UserDAO {
    Optional&lt;User&gt; findById(String username) throws DAOException;
}

class ServiceException extends Exception

class UserManager {
    private UserDAO userDAO;
    
    public boolean registerNewUser(String username, String password) throws ServiceException {
        try {
            if (userDAO.findById(username).isDefined()) {
                return false;
            } 
            //....
        } catch(RuntimeException e) {
            throw e;
        } catch (Exception e) {
            throw new ServiceException(e);
        }
    }
}
</code></pre>
<p>This is logically consistent approach, but requires <strong>a lot</strong> of boilerplate and ceremony. Depending on the application type this might be justified or not.</p>
<h1 id="dont-pass-null--dont-return-null"><a class="header" href="#dont-pass-null--dont-return-null">Don't pass null / Don't return null</a></h1>
<p>This advice that is hard to disagree with. "null" is one true magic value:</p>
<pre><code class="language-java">jshell&gt; null instanceof String
$1 ==&gt; false

jshell&gt; (String) null
$2 ==&gt; null

jshell&gt; String str = null;
str ==&gt; null
</code></pre>
<p>Despite null not being subtype of String, it can be casted to String without errors and even assigned without a cast. <strong>Magic!</strong></p>
<p>null and unchecked exceptions are almost ignored by type system. That's what makes them easy to use and hard to handle.</p>
<p>You pretty much always can introduce unsafe  (and logically backward incompartible) changes, without type system making a peep about it:</p>
<div class="code-comparison">
    <div class="code-column" >
        <pre class="ignore"><code class="language-java">public Long sum(List<Long> list) {
   long sum = 0;
   for(Long i: list) {
       sum += i;
   }
   return sum; 
}
</code></pre>
    </div>
    <div class="code-column">
        <pre class="ignore"><code class="language-java">public Long sum(List<Long> list) {
   if(random() < 0.5) {
       return null; // lol
   } else {
       throw new RuntimeException("OMEGA LOL");
   }
   long sum = 0;
   for(Long i: list) {
       sum += i;
   }
   return sum; 
}</code></pre>
    </div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-9-unit-tests"><a class="header" href="#chapter-9-unit-tests">Chapter 9: Unit Tests</a></h1>
<p>Martin claims:</p>
<div class="book-quote">
What this team did not realize was that having dirty tests is equivalent to, if not worse than, having no tests.
</div>
<p>This lacks crucial nuance: messy tests that actually test software are better than no tests. <br/></p>
<p>To repeat the example of when that is true: <a href="https://news.ycombinator.com/item?id=18442941">Oracle Database: an unimaginable horror! You can't change a single line of code in the product without breaking 1000s of existing tests</a> <br/>
Oracle Database is a very reliable software (as of 2024), it comes at the cost of thousands of people suffering through the setup, but as a customer I enjoy its robustness.</p>
<p>However proliferation of mocking frameworks lead to the situation when developers spent time tweaking mock expectations and then testing the mocks. Those are indeed often messy is useless.</p>
<p>The chapter highlights two competing approaches through refactoring examples.</p>
<p>First, it presents an example of a refactoring that I mostly agree with:</p>
<div class="code-comparison" >
<div class="code-column" style="flex:0">
<div class="code-column-title">Original Code: </div>
<pre class="ignore"><code class="language-java" style="font-size: 13px !important">public void testGetPageHieratchyAsXml() throws Exception {
    crawler.addPage(root, PathParser.parse("PageOne"));
    crawler.addPage(root, PathParser.parse("PageOne.ChildOne"));
    crawler.addPage(root, PathParser.parse("PageTwo"));
    &nbsp;
    request.setResource("root");
    request.addInput("type", "pages");
    Responder responder = new SerializedPageResponder();
    SimpleResponse response =
        (SimpleResponse) responder.makeResponse(
            new FitNesseContext(root), request);
    String xml = response.getContent();
    &nbsp;
    assertEquals("text/xml", response.getContentType());
    assertSubString("<name>PageOne</name>", xml);
    assertSubString("<name>PageTwo</name>", xml);
    assertSubString("<name>ChildOne</name>", xml);
}
&nbsp;
public void testGetPage_cLinks() throws Exception {
    WikiPage pageOne = 
    crawler.addPage(root, PathParser.parse("PageOne"));
    crawler.addPage(root, PathParser.parse("PageOne.ChildOne"));
    crawler.addPage(root, PathParser.parse("PageTwo"));
    &nbsp;
    PageData data = pageOne.getData();
    WikiPageProperties properties = data.getProperties();
    WikiPageProperty symLinks = 
        properties.set(SymbolicPage.PROPERTY_NAME);
    symLinks.set("SymPage", "PageTwo");
    pageOne.commit(data);
    &nbsp;
    request.setResource("root");
    request.addInput("type", "pages");
    Responder responder = new SerializedPageResponder();
    SimpleResponse response =
        (SimpleResponse) responder.makeResponse(
            new FitNesseContext(root), request);
    String xml = response.getContent();
    &nbsp;
    assertEquals("text/xml", response.getContentType());
    assertSubString("<name>PageOne</name>", xml);
    assertSubString("<name>PageTwo</name>", xml);
    assertSubString("<name>ChildOne</name>", xml);
    assertNotSubString("SymPage", xml);
}
&nbsp;
public void testGetDataAsHtml() throws Exception {
    crawler.addPage(root, 
    PathParser.parse("TestPageOne"), "test page");
    &nbsp;
    request.setResource("TestPageOne"); 
    request.addInput("type", "data");
    Responder responder = new SerializedPageResponder();
    SimpleResponse response =
        (SimpleResponse) responder.makeResponse(
            new FitNesseContext(root), request);
    String xml = response.getContent();
    &nbsp;
    assertEquals("text/xml", response.getContentType());
    assertSubString("test page", xml);
    assertSubString("&gt;Test", xml);
}</code></pre>
</div>
<div class="code-column">
<div class="code-column-title">Proposed rewrite:</div>
<pre><code class="language-java" style="font-size: 13px !important">public void testGetPageHierarchyAsXml() throws Exception {
    makePages("PageOne", "PageOne.ChildOne", "PageTwo");
    &nbsp;
    submitRequest("root", "type:pages");
    &nbsp;
    assertResponseIsXML();
    assertResponseContains(
        "<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>"
    );
}
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
public void testGetPage_cLinks() throws Exception {
    WikiPage page = makePage("PageOne");
    makePages("PageOne.ChildOne", "PageTwo");
    &nbsp;
    addLinkTo(page, "PageTwo", "SymPage");
    &nbsp;
    submitRequest("root", "type:pages");
    &nbsp;
    assertResponseIsXML();
    assertResponseContains(
        "<name>PageOne</name>", "<name>PageTwo</name>",
        "<name>ChildOne</name>"
    );
    assertResponseDoesNotContain("SymPage");
}
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
public void testGetDataAsXml() throws Exception {
    makePageWithContent("TestPageOne", "test page");
&nbsp;
    submitRequest("TestPageOne", "type:data");
&nbsp;
    assertResponseIsXML();
    assertResponseContains("test page", "&gt;Test");
}</code></pre>
</div>
</div>
<p>The <span style="color: lightgreen">good</span>:</p>
<p>Â Â Â Â Â Â  - the introduced abstractions are useful and reusable</p>
<p>The <span style="color: red">bad</span>:</p>
<p>Â Â Â Â Â Â  - Martin introduces <strong>global mutable state</strong> (global in terms of the test suite)</p>
<p>Big drawback of this global mutable state - now tests can not be run in parallel. Hence the execution of these 3 tests will take 3x more time.</p>
<p>Another case of <a href="https://www.computerenhance.com/p/clean-code-horrible-performance">"'Clean' Code, Horrible Performance"</a>.</p>
<p>This is self-inflicted harm from a painful idea that no parameters is always better than 1+.</p>
<p>By fixing it:</p>
<pre><code class="language-java">public void testGetDataAsXml() throws Exception {
    var page = makePageWithContent("TestPageOne", "test page");

    var response = submitRequest(page, "type:data");

    assertIsXML(response);
    assertContains(response, "test page", "&lt;Test");
}
</code></pre>
<p>We get the <code>BUILD</code>-<code>OPERATE</code>-<code>CHECK</code> pattern without hidden state. Tests are isolated and can run in parallel.</p>
<hr />
<p>The first example in this chapter shows how adding domain-specific details can improve readability.
The second example shows how domain-specific abstractions can go wrong:</p>
<pre><code class="language-java">@Test
public void turnOnLoTempAlarmAtThreashold() throws Exception {
    hw.setTemp(WAY_TOO_COLD);
    controller.tic();
    assertTrue(hw.heaterState());
    assertTrue(hw.blowerState());
    assertFalse(hw.coolerState());
    assertFalse(hw.hiTempAlarm());
    assertTrue(hw.loTempAlarm());
}
</code></pre>
<p>is proposed to be rewritten as:</p>
<pre><code class="language-java">@Test
public void turnOnLoTempAlarmAtThreshold() throws Exception {
    wayTooCold();
    assertEquals("HBchL", hw.getState());
}

// Upper case means "on," lower case means "off," and the letters are always in the following order: 
// {heater, blower, cooler, hi-temp-alarm, lo-temp-alarm}
</code></pre>
<p>The mini-DSL makes things harder to read, not easier.
The "HBchL" encoding requires extra mental effort to decode, which defeats the purpose of making the test more readable.</p>
<p>Why not "heater:on, blower:on, cooler:off, hi-temp-alarm:off, lo-temp-alarm:on" ?</p>
<p><code>wayTooCold();</code> - is also very weird grammar. Is it a verb or verb phrase? Why do we need to hide <code>controller.tic()</code>?</p>
<p>In the <code>BUILD</code>-<code>OPERATE</code>-<code>CHECK</code> pattern: <code>Controller.tic()</code> is the <code>OPERATE</code>!</p>
<pre><code class="language-java">wayTooCold();
assertEquals("HBchL", hw.getState());
</code></pre>
<p>This is not <code>BUILD</code>-<code>OPERATE</code>-<code>CHECK</code>. Thi is <code>WHY</code>-<code>WTF</code></p>
<p>A more natural approach:</p>
<pre><code class="language-java">@Test
public void turnOnLoTempAlarmAtThreashold() throws Exception {
    hw.setTempF(10); // too cold

    controller.tic();

    assertEquals(
        "heater:on, blower:on, cooler:off, hi-temp-alarm:off, lo-temp-alarm:on",
        hw.getState()
    );
}
</code></pre>
<p>Again in modern languages, like Scala</p>
<pre><code class="language-scala">@Test
def turnOnLoTempAlarmAtThreashold() {
    hw.setTemp(10.F) // too cold

    controller.tic()

    assertEquals(
        Status(heaterOn = true, blowerOn = false, coolerOn = false, 
            hiTempAlarm = false, loTempAlarm = true
        ),
        hw.getState()
    )
}
</code></pre>
<p>No need for mini-DSLs, the language itself is expressive enough to keep things clean and clear.</p>
<h3 id="final-nitpick-test-performance-matters"><a class="header" href="#final-nitpick-test-performance-matters">Final nitpick: Test Performance Matters</a></h3>
<div class="book-quote">
The getState function is shown in Listing 9-6. Notice that this is not very efficient code. To make it efficient, I probably should have used a StringBuffer.
<pre><code class="language-java">public String getState() {
    String state = "";
    state += heater ? "H" : "h";
    state += blower ? "B" : "b";
    state += cooler ? "C" : "c";
    state += hiTempAlarm ? "H" : "h";
    state += loTempAlarm ? "L" : "l";
    return state;
}
</code></pre>
<p>StringBuffers are a bit ugly.</p>
</div>
<p>Not only are StringBuffers ugly, but theyâ€™re also slow (the book shows it age). StringBuffer is synchronized for multi-threaded access, adding unnecessary overhead.
Fortunately, modern javac compiler can optimize sligtly modified version of <code>getState</code> method to use <a href="https://www.baeldung.com/java-string-concatenation-invoke-dynamic">the most optimal stategy</a>:</p>
<div class="code-comparison">
    <div class="code-column" style="flex:0">
        <div class="code-column-title">Java Code: </div>
        <pre class="ignore"><code class="language-java">public String getState() {
  return (heater ? "H" : "h") + 
          (blower ? "B" : "b") +
          (cooler ? "C" : "c") +
          (hiTempAlarm ? "H" : "h") +
          (loTempAlarm ? "L" : "l");
 }</code></pre>
    </div>
    <div class="code-column">
        <div class="code-column-title">Decompiled with javap (jdk 21):</div>
        <pre class="ignore"><code class="language-java"> public java.lang.String getState();
  descriptor: ()Ljava/lang/String;
  flags: (0x0001) ACC_PUBLIC
  Code:
    stack=5, locals=1, args_size=1
       0: aload_0
       1: getfield      #7                  // Field heater:Z
       4: ifeq          12
       7: ldc           #13                 // String H
       9: goto          14
      12: ldc           #15                 // String h
      14: aload_0
      15: getfield      #17                 // Field blower:Z
      18: ifeq          26
      21: ldc           #20                 // String B
      23: goto          28
      26: ldc           #22                 // String b
      28: aload_0
      29: getfield      #24                 // Field cooler:Z
      32: ifeq          40
      35: ldc           #27                 // String C
      37: goto          42
      40: ldc           #29                 // String c
      42: aload_0
      43: getfield      #31                 // Field hiTempAlarm:Z
      46: ifeq          54
      49: ldc           #13                 // String H
      51: goto          56
      54: ldc           #15                 // String h
      56: aload_0
      57: getfield      #34                 // Field loTempAlarm:Z
      60: ifeq          68
      63: ldc           #37                 // String L
      65: goto          70
      68: ldc           #39                 // String l
      <span class="code-comment-trigger">â–º</span><span class="reviewable-line">70: invokedynamic #41,  0 <span class="code-comment">Details on <a href="https://www.baeldung.com/java-string-concatenation-invoke-dynamic">how it works</a></span></span>            // InvokeDynamic #0:makeConcatWithConstants: (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
      75: areturn
        </code></pre>
    </div>
</div>
<div class="book-quote">
There are things that you might never do in a production environment that are perfectly fine in a test environment. Usually they involve issues of memory or CPU efficiency. But they never involve issues of cleanliness.
</div>
<p>Wrong. Test performance is crucial at scale. Slow tests mean:</p>
<p>Slow tests can and <strong>will</strong> kill development speed. Ignoring tests performance in a large codebase means longer CI/CD cycles, slower iteration, stagnation, suffering and death ðŸ’€</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-10-classes"><a class="header" href="#chapter-10-classes">Chapter 10: Classes</a></h1>
<p>Written with Jeff Langr, this chapter reveals a fundamental contradiction in Clean Code's approach:</p>
<ul>
<li>Classes should have minimal responsibilities (ideally one)</li>
<li>Classes should have few instance variables</li>
<li>Methods should have few parameters</li>
</ul>
<p>See the problem? Reducing method parameters forces state into instance variables. Keeping instance variables minimal requires creating more classes.
Martin's solution?
More classes is better:</p>
<div class="book-quote">
So breaking a large function into many smaller functions often gives us the opportunity to split several smaller classes out as well. 
This gives our program a much better organization and a more transparent structure.
</div>
<p>And then he does his favorite trick: shows obfuscated code (admittedly machine-generated) and refactors it using all his favorite hits:</p>
<ul>
<li>Classes with global mutable state</li>
<li>Parameters moved to instance fields</li>
<li>Tiny single-use private methods</li>
<li>Essay-length names</li>
</ul>
<pre><code class="language-java">public class PrintPrimes {
     public static void main(String[] args) {
       final int M = 1000;
       final int RR = 50;
       final int CC = 4;
       final int WW = 10;
       final int ORDMAX = 30;
       int P[] = new int[M + 1];
       int PAGENUMBER;
       int PAGEOFFSET;
       int ROWOFFSET;
       int C;

       int J;
       int K;
       boolean JPRIME;
       int ORD;
       int SQUARE;
       int N;
       int MULT[] = new int[ORDMAX + 1];

       J = 1;
       K = 1;
       P[1] = 2;
       ORD = 2;
       SQUARE = 9;

       while (K &lt; M) {
         do {
           J = J + 2;
           if (J == SQUARE) {
             ORD = ORD + 1;
             SQUARE = P[ORD] * P[ORD];
             MULT[ORD - 1] = J;
           }
           N = 2;
           JPRIME = true;
           while (N &lt; ORD &amp;&amp; JPRIME) {
             while (MULT[N] &lt; J)
               MULT[N] = MULT[N] + P[N] + P[N];
             if (MULT[N] == J)
               JPRIME = false;
             N = N + 1;
          }
        } while (!JPRIME);
        K = K + 1;
        P[K] = J;
     }
     {
        PAGENUMBER = 1;
        PAGEOFFSET = 1;
        while (PAGEOFFSET &lt;= M) {
          System.out.println("The First " + M +
                                     " Prime Numbers --- Page " + PAGENUMBER);
          System.out.println("");
          for (ROWOFFSET = PAGEOFFSET; ROWOFFSET &lt; PAGEOFFSET + RR; ROWOFFSET++){
             for (C = 0; C &lt; CC;C++)
             if (ROWOFFSET + C * RR &lt;= M)
               System.out.format("%10d", P[ROWOFFSET + C * RR]);
             System.out.println("");
          }
          System.out.println("\f");
          PAGENUMBER = PAGENUMBER + 1;
          PAGEOFFSET = PAGEOFFSET + RR * CC;
      }
     }
    }
}
</code></pre>
<p>is refactored to:</p>
<pre><code class="language-java">package literatePrimes;

public class PrimePrinter {
    public static void main(String[] args) {
        final int NUMBER_OF_PRIMES = 1000;
        int[] primes = PrimeGenerator.generate(NUMBER_OF_PRIMES);

        final int ROWS_PER_PAGE = 50;
        final int COLUMNS_PER_PAGE = 4;
        RowColumnPagePrinter tablePrinter = 
            new RowColumnPagePrinter(ROWS_PER_PAGE,
                                    COLUMNS_PER_PAGE,
                                    "The First " + NUMBER_OF_PRIMES +
                                            " Prime Numbers");
        tablePrinter.print(primes);
    }
}

package literatePrimes;

import java.io.PrintStream;

public class RowColumnPagePrinter {
    private int rowsPerPage;
    private int columnsPerPage;
    private int numbersPerPage;
    private String pageHeader;
    private PrintStream printStream;

    public RowColumnPagePrinter(int rowsPerPage,
                                int columnsPerPage,
                                String pageHeader) {
        this.rowsPerPage = rowsPerPage;
        this.columnsPerPage = columnsPerPage;
        this.pageHeader = pageHeader;
        numbersPerPage = rowsPerPage * columnsPerPage;
        printStream = System.out;
    }

    public void print(int data[]) {
        int pageNumber = 1;
        for (int firstIndexOnPage = 0;
             firstIndexOnPage &lt; data.length;
             firstIndexOnPage += numbersPerPage) {
            int lastIndexOnPage =
                Math.min(firstIndexOnPage + numbersPerPage - 1,
                         data.length - 1);
            printPageHeader(pageHeader, pageNumber);
            printPage(firstIndexOnPage, lastIndexOnPage, data);
            printStream.println("\f");
            pageNumber++;
        }
    }

    private void printPage(int firstIndexOnPage,
                          int lastIndexOnPage,
                          int[] data) {
        int firstIndexOfLastRowOnPage =
            firstIndexOnPage + rowsPerPage - 1;
        for (int firstIndexInRow = firstIndexOnPage;
             firstIndexInRow &lt;= firstIndexOfLastRowOnPage;
             firstIndexInRow++) {
            printRow(firstIndexInRow, lastIndexOnPage, data);
            printStream.println("");
        }
    }

    private void printRow(int firstIndexInRow,
                          int lastIndexOnPage,
                          int[] data) {
        for (int column = 0; column &lt; columnsPerPage; column++) {
            int index = firstIndexInRow + column * rowsPerPage;
            if (index &lt;= lastIndexOnPage)
                printStream.format("%10d", data[index]);
        }
    }

    private void printPageHeader(String pageHeader,
                                int pageNumber) {
        printStream.println(pageHeader + " --- Page " + pageNumber);
        printStream.println("");
    }

    public void setOutput(PrintStream printStream) {
        this.printStream = printStream;
    }
}

package literatePrimes;

import java.util.ArrayList;

public class PrimeGenerator {
    private static int[] primes;
    private static ArrayList&lt;Integer&gt; multiplesOfPrimeFactors;

    protected static int[] generate(int n) {
        primes = new int[n];
        multiplesOfPrimeFactors = new ArrayList&lt;Integer&gt;();
        set2AsFirstPrime();
        checkOddNumbersForSubsequentPrimes();
        return primes;
    }

    private static void set2AsFirstPrime() {
        primes[0] = 2;
        multiplesOfPrimeFactors.add(2);
    }

    private static void checkOddNumbersForSubsequentPrimes() {
        int primeIndex = 1;
        for (int candidate = 3;
             primeIndex &lt; primes.length;
             candidate += 2) {
            if (isPrime(candidate))
                primes[primeIndex++] = candidate;
        }
    }

    private static boolean isPrime(int candidate) {
        if (isLeastRelevantMultipleOfNextLargerPrimeFactor(candidate)) {
            multiplesOfPrimeFactors.add(candidate);
            return false;
        }
        return isNotMultipleOfAnyPreviousPrimeFactor(candidate);
    }

    private static boolean
    isLeastRelevantMultipleOfNextLargerPrimeFactor(int candidate) {
        int nextLargerPrimeFactor = primes[multiplesOfPrimeFactors.size()];
        int leastRelevantMultiple = nextLargerPrimeFactor * nextLargerPrimeFactor;
        return candidate == leastRelevantMultiple;
    }

    private static boolean
    isNotMultipleOfAnyPreviousPrimeFactor(int candidate) {
        for (int n = 1; n &lt; multiplesOfPrimeFactors.size(); n++) {
            if (isMultipleOfNthPrimeFactor(candidate, n))
                return false;
        }
        return true;
    }

    private static boolean
    isMultipleOfNthPrimeFactor(int candidate, int n) {
        return
            candidate == smallestOddNthMultipleNotLessThanCandidate(candidate, n);
    }

    private static int
    smallestOddNthMultipleNotLessThanCandidate(int candidate, int n) {
        int multiple = multiplesOfPrimeFactors.get(n);
        while (multiple &lt; candidate)
            multiple += 2 * primes[n];
        multiplesOfPrimeFactors.set(n, multiple);
        return multiple;
    }
}
</code></pre>
<p>Martin celebrates the growth:</p>
<div class="book-quote">
The first thing you might notice is that the program got a lot longer. It went from a little over one page to nearly three pages in length. There are several reasons for this growth. 
First, the refactored program uses longer, more descriptive variable names. 
Second, the refactored program uses function and class declarations as a way to add commentary to the code. 
Third, we used whitespace and formatting techniques to keep the program readable.
</div>
<p>The real reason for the bloat: excessive method and class extraction. What should be three clear methods (main, generate primes, format output) becomes a sprawling hierarchy of tiny classes.</p>
<div class="book-quote">
"Notice how the program has been split into three main responsibilities."
</div>
<p>The original solution, though ugly, was contained. Refactored version is glutted and bloated, scattered across multiple files, and still ugly. Â¯\<em>(ãƒ„)</em>/Â¯</p>
<h1 id="organizing-for-change"><a class="header" href="#organizing-for-change">Organizing for Change</a></h1>
<div class="book-quote">
For most systems, change is continual. Every change subjects us to the risk that the remainder of the system no longer works as intended. In a clean system we organize our classes so as to reduce the risk of change.
</div>
<p>I think our best defense against risky changes is tests. Code structure can erode silently - tests fail loudly.</p>
<p>I agree that it's important for code structure to guide and accelerate future development, but it's not about risk.</p>
<p>In this chapter Martin advocates for 3 components of his future SOLID framework:</p>
<ul>
<li>Single Responsibility</li>
<li>Open/Closed</li>
<li>Dependency Injection</li>
</ul>
<p>I don't mind SRP but "Responsibility" is an abstract concept.</p>
<pre><code class="language-java">public class Sql { 
    public Sql(String table, Column[] columns)
    public String create()
    public String insert(Object[] fields)
    public String selectAll()
    public String findByKey(String keyColumn, String keyValue)
    public String select(Column column, String pattern)
    public String select(Criteria criteria)
    public String preparedInsert()
    private String columnList(Column[] columns)
    private String valuesList(Object[] fields, final Column[] columns)
    private String selectWithCriteria(String criteria)
    private String placeholderList(Column[] columns)
}
</code></pre>
<p>Is this class's single responsibility "generating SQL statements"? Or does it have seven responsibilities, one per query type? The definition depends entirely on your abstraction level.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-11-systems"><a class="header" href="#chapter-11-systems">Chapter 11: Systems</a></h1>
<p>This is a mixed bag of relatively OK-ish approaches, relatively outdated advice, and critique of the APIs that lost its relevance a decade ago.</p>
<p>It focuses on managing cross-cutting concerns, but through a 2009 lens that's now clouded.
The book discusses four implementation approaches:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Jakarta_Enterprise_Beans">Enterprise JavaBeans - ejb</a> - obsolete</li>
<li>Proxies:
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html">JDK dynamic proxies</a> - still relevant</li>
<li><a href="https://asm.ow2.io/">ASM-based proxies</a> - relevant, bbut superseded by <a href="https://bytebuddy.net/">byte-buddy</a></li>
</ul>
</li>
<li><a href="https://projects.eclipse.org/projects/tools.aspectj">aspectj</a> - largely obsolete</li>
<li>Plain Java code</li>
</ul>
<p>Martin ultimately advocates for plain Java with better modularity and cleaner separation of concerns. To address Java's verbosity, he suggests using Domain-Specific Languages (DSLs).
The core message about separation of concerns remains valid, but the presentation has three major problems:</p>
<ol>
<li>Most referenced technologies are obsolete, making the chapter confusing for modern developers</li>
<li>The DSL argument lacks concrete examples, instead bizarrely referencing Christopher Alexander's architectural patterns</li>
<li>The chapter holds up JMock as exemplary DSL design, yet the most successful Java mocking framework (Mockito) explicitly rejected DSLs:</li>
</ol>
<blockquote>
<p>"The less DSL the better. Interactions are just method calls. Method calls are simple, DSL is complex."</p>
<p>from <a href="https://szczepiq.wordpress.com/2008/01/14/mockito/">Mockito announcement</a></p>
</blockquote>
<p>This illustrates a broader issue with the chapter: its technical recommendations proved less durable than its architectural principles.
While "separate your concerns" remains good advice, the specific approaches it recommends haven't stood the test of time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-12-emergence"><a class="header" href="#chapter-12-emergence">Chapter 12: Emergence</a></h1>
<p>Is written by Jeff Langr.</p>
<p>It's pretty much about 4 principles of <a href="https://www.amazon.com/gp/product/0201616416">good design from Kent Beck</a>:</p>
<ul>
<li>Runs all the tests</li>
<li>Contains no duplication</li>
<li>Expresses the intent of the programmer</li>
<li>Minimizes the number of classes and methods</li>
</ul>
<p>The chapter promises that if you follow these rules, the emergent design of the system will be clean. Maybe? The proof is left as an exercises for a reader.</p>
<p>My favourite part is the last section: "Minimal Classes and Methods"</p>
<div class="book-quote">
Even concepts as fundamental as elimination of duplication, code expressiveness, and the SRP can be taken too far. 
In an effort to make our classes and methods small, we might create too many tiny classes and methods. 
So this rule suggests that we also keep our function and class counts low.
<p>High class and method counts are sometimes the result of pointless dogmatism.</p>
</div>
<p>Yep. This pretty much sums up everything what is wrong with the rest of this book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-13-concurrency"><a class="header" href="#chapter-13-concurrency">Chapter 13: Concurrency</a></h1>
<p>Don't bother. The topic is too complex to be just a chapter.</p>
<h2 id="things-to-read-instead"><a class="header" href="#things-to-read-instead">Things to read instead</a></h2>
<ul>
<li><a href="https://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601">Java Concurrency In Practive</a> by Brian Goetz<br/>
Despite being old this is still the best book to learn about concurrency on JVM. This book can not be skipped.</li>
<li><a href="https://www.youtube.com/playlist?list=PLL8woMHwr36EDxjUoCzboZjedsnhLP1j4">Video lecture: Java Concurrency and Multithreading</a> by Jakob Jenkov<br/>
For those who can not read books.</li>
<li><a href="https://arxiv.org/abs/1701.00854">Is Parallel Programming Hard, And, If So, What Can You Do About It?</a> by Paul E. McKenney<br/>
Explores parallel programming from low-level perspective: hardware, system languages and operating system primitives.</li>
<li><a href="https://www.goodreads.com/book/show/52819132-a-primer-on-memory-consistency-and-cache-coherence">A Primer on Memory Consistency and Cache Coherence</a> by Vijay Nagarajan <br/>
Connects theoretical computer science, math formalisms and hardware implementations.</li>
<li><a href="https://www.amazon.com/Shared-Memory-Synchronization-Synthesis-Lectures-Architecture/dp/160845956X">Shared-Memory Synchronization</a> by  Michael L. Scott<br/>
On design and implementation concurrent data-structures.</li>
<li><a href="https://www.amazon.com/Art-Multiprocessor-Programming-Maurice-Herlihy-dp-0124159508/dp/0124159508">The Art of Multiprocessor Programming</a> by Maurice Herlihy<br/>
Lays out theoretical foundation for multi-threaded programming.</li>
</ul>
<h3 id="memory-models"><a class="header" href="#memory-models">Memory Models</a></h3>
<ul>
<li><a href="https://shipilev.net/blog/2014/jmm-pragmatics/">Java Memory Model Pragmatics</a></li>
<li>"Memory Models" by Russ Cox: <a href="https://research.swtch.com/hwmm">part 1 - Hardware</a>, <a href="https://research.swtch.com/plmm">part 2 - Programming Languages</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-14-successive-refinement"><a class="header" href="#chapter-14-successive-refinement">Chapter 14: Successive Refinement</a></h1>
<p>This chapter is an example of how he arrives to "clean code" solution for a specific task.</p>
<p>When I first read the book in 2009 I've loved it.
It felt like the best programming book I'd ever seen.
But even then, this chapter left me with an uneasy feeling about his solution. I spent a lot of time re-reading it, thinking I was too junior to understand why it was good.
15 years later I still don't like his solution, but now I can explain why.</p>
<p>The task: create a command-line argument parser with this interface:</p>
<div class="book-quote">
<pre><code class="language-java">public static void main(String[] args) {
    try {
        Args arg = new Args("l,p#,d*", args);
        boolean logging = arg.getBoolean('l');
        int port = arg.getInt('p');
        String directory = arg.getString('d');
        executeApplication(logging, port, directory);
    } catch (ArgsException e) {
        System.out.printf("Argument error: %s\n", e.errorMessage());
    }
}
</code></pre>
</div>
<p>This is the solution that Martin is proud of and insists that it needs to be carefully studied:</p>
<div class="book-quote">
<pre><code class="language-java">package com.objectmentor.utilities.args;
&nbsp;
import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;
import java.util.*;
&nbsp;
public class Args {
    private Map&lt;Character, ArgumentMarshaler&gt; marshalers;
    private Set&lt;Character&gt; argsFound;
    private ListIterator&lt;String&gt; currentArgument;
&nbsp;
    public Args(String schema, String[] args) throws ArgsException {
        marshalers = new HashMap&lt;Character, ArgumentMarshaler&gt;();
        argsFound = new HashSet&lt;Character&gt;();
&nbsp;
        parseSchema(schema);
        parseArgumentStrings(Arrays.asList(args));
    }
&nbsp;
    private void parseSchema(String schema) throws ArgsException {
        for (String element : schema.split(â€œ,â€))
            if (element.length() > 0)
                parseSchemaElement(element.trim());
    }
&nbsp;
    private void parseSchemaElement(String element) throws ArgsException {
        char elementId = element.charAt(0);
        String elementTail = element.substring(1);
        validateSchemaElementId(elementId);
        if (elementTail.length() == 0)
            marshalers.put(elementId, new BooleanArgumentMarshaler());
        else if (elementTail.equals(â€œ*â€))
            marshalers.put(elementId, new StringArgumentMarshaler());
        else if (elementTail.equals(â€œ#â€))
            marshalers.put(elementId, new IntegerArgumentMarshaler());
        else if (elementTail.equals(â€œ##â€))
            marshalers.put(elementId, new DoubleArgumentMarshaler());
        else if (elementTail.equals(â€œ[*]â€))
            marshalers.put(elementId, new StringArrayArgumentMarshaler());
        else
            throw new ArgsException(INVALID_ARGUMENT_FORMAT, elementId, elementTail);
    }
&nbsp;
    private void validateSchemaElementId(char elementId) throws ArgsException {
        if (!Character.isLetter(elementId))
            throw new ArgsException(INVALID_ARGUMENT_NAME, elementId, null);
    }
&nbsp;
    private void parseArgumentStrings(List&lt;String&gt; argsList) throws ArgsException 
    {
        for (currentArgument = argsList.listIterator(); currentArgument.hasNext();) 
        {
            String argString = currentArgument.next();
            if (argString.startsWith(â€œ-â€)) {
                parseArgumentCharacters(argString.substring(1));
            } else {
                currentArgument.previous();
                break;
            }
        }
    }
&nbsp;
    private void parseArgumentCharacters(String argChars) throws ArgsException {
        for (int i = 0; i < argChars.length(); i++)
            parseArgumentCharacter(argChars.charAt(i));
    }
&nbsp;
    private void parseArgumentCharacter(char argChar) throws ArgsException {
        ArgumentMarshaler m = marshalers.get(argChar);
        if (m == null) {
            throw new ArgsException(UNEXPECTED_ARGUMENT, argChar, null);
        } else {
            argsFound.add(argChar);
            try {
                m.set(currentArgument);
            } catch (ArgsException e) {
                e.setErrorArgumentId(argChar);
                throw e;
            }
        }
    }
&nbsp;
    public boolean has(char arg) {
        return argsFound.contains(arg);
    }
&nbsp;
    public int nextArgument() {
        return currentArgument.nextIndex();
    }
&nbsp;
    public boolean getBoolean(char arg) {
        return BooleanArgumentMarshaler.getValue(marshalers.get(arg));
    }
&nbsp;
    public String getString(char arg) {
        return StringArgumentMarshaler.getValue(marshalers.get(arg));
    }
&nbsp;
    public int getInt(char arg) {
        return IntegerArgumentMarshaler.getValue(marshalers.get(arg));
    }
&nbsp;
    public double getDouble(char arg) {
        return DoubleArgumentMarshaler.getValue(marshalers.get(arg));
    }
&nbsp;
    public String[] getStringArray(char arg) {
        return StringArrayArgumentMarshaler.getValue(marshalers.get(arg));
    }
}
&nbsp;
//....
&nbsp;
public class StringArgumentMarshaler implements ArgumentMarshaler {
  private String stringValue = null;
&nbsp;
  public void set(Iterator<String> currentArgument) throws ArgsException {
    try {
      stringValue = currentArgument.next();
    } catch (NoSuchElementException e) {
      throw new ArgsException(MISSING_STRING);
    }
  }
&nbsp;
  public static String getValue(ArgumentMarshaler am) {
    if (am != null && am instanceof StringArgumentMarshaler)
      return ((StringArgumentMarshaler) am).stringValue;
    else
      return â€â€;
  }
}
</code></pre>
</div>
<h2 id="the-problems"><a class="header" href="#the-problems">The Problems</a></h2>
<h3 id="1-weird-interface-design"><a class="header" href="#1-weird-interface-design">1. Weird Interface Design</a></h3>
<p>Look at StringArgumentMarshaler:</p>
<div class="book-quote">
<pre><code class="language-java">public class StringArgumentMarshaler implements ArgumentMarshaler {
  private String stringValue = null;
&nbsp;
  public void set(Iterator&lt;String&gt; currentArgument) throws ArgsException {
    try {
      stringValue = currentArgument.next();
    } catch (NoSuchElementException e) {
      throw new ArgsException(MISSING_STRING);
    }
  }
&nbsp;
  public static String getValue(ArgumentMarshaler am) {
    if (am != null && am instanceof StringArgumentMarshaler)
      return ((StringArgumentMarshaler) am).stringValue;
    else
      return "";
  }
}</code></pre>
</div>
<p><code>set</code> is an instance method but <code>getValue</code> is static. Why not take a simpler approach?</p>
<pre><code class="language-java">public interface ArgumentMarshaler&lt;T&gt; {
    void set(Iterator&lt;String&gt; currentArgument) throws ArgsException;
    Optional&lt;T&gt; get();
}
</code></pre>
<h3 id="2-mixed-up-responsibilities"><a class="header" href="#2-mixed-up-responsibilities">2. Mixed Up Responsibilities</a></h3>
<p>The StringArgumentMarshaler (and all other marshalers) tries to do two things:</p>
<ul>
<li>Parse token streams</li>
<li>Store and provide parsed values</li>
</ul>
<p>From an interface design perspective, this would make more sense:</p>
<pre><code class="language-java">public interface ArgumentParser&lt;T&gt; {
    T parse(Iterator&lt;String&gt; currentArgument) throws ArgsException;
}
</code></pre>
<h3 id="3-messy-error-handling"><a class="header" href="#3-messy-error-handling">3. Messy Error Handling</a></h3>
<p>The <code>set</code> method does some validation, but <code>get</code> just falls back to type-specific default values if something's wrong.
Silent failures with default values can lead to subtle bugs.</p>
<p>Check out how the IntegerArgumentMarshaler assumes 0 is a safe default:</p>
<div class="book-quote">
<pre><code class="language-java">public static int getValue(ArgumentMarshaler am) {
    if (am != null && am instanceof IntegerArgumentMarshaler)
        return ((IntegerArgumentMarshaler) am).intValue;
    else
        return 0;
}
</code></pre>
</div>
<p>Here's how this can bite you:</p>
<pre><code class="language-java">Args arg = new Args("l,p#,p*", args); // p is marked as string here
int port = arg.getInt('p');           // but trying to read as int
</code></pre>
<p>The library quietly gives you 0 as the port value, which is extra bad since <a href="https://www.lifewire.com/port-0-in-tcp-and-udp-818145">port 0 means something special in Unix</a>.</p>
<p>The argument parsing library is expected to be generic - i.e. it's expected to be used in wide range of domains.<br/>
In this context, it is not safe to assume default values based on type information alone.</p>
<h3 id="4-state-management-gone-wrong"><a class="header" href="#4-state-management-gone-wrong">4. State Management Gone Wrong</a></h3>
<p>The Args class mixes up final results and intermediate processing state in the same scope, while keeping the state it doesn't need:</p>
<div class="book-quote">
<pre><code class="language-java">public class Args {
    private Map&lt;Character, ArgumentMarshaler&gt; marshalers;  // This has the final results
    private Set&lt;Character&gt; argsFound;                      // Don't need this, can get from marshalers
    private ListIterator&lt;String&gt; currentArgument;          // Only needed during parsing
</code></pre>
</div>
<h3 id="5-overcomplicated-errors"><a class="header" href="#5-overcomplicated-errors">5. Overcomplicated Errors</a></h3>
<p>Let's talk about that ArgsException class.</p>
<div class="book-quote">
<pre><code class="language-java">public class ArgsException extends Exception {
  private char errorArgumentId = â€™\0â€™;
  private String errorParameter = null;
  private ErrorCode errorCode = OK;
&nbsp;
  public ArgsException() {}
&nbsp;
  public ArgsException(String message) {super(message);}
&nbsp;
  public ArgsException(ErrorCode errorCode) {
    this.errorCode = errorCode;
  }
&nbsp;
  public ArgsException(ErrorCode errorCode, String errorParameter) {
    this.errorCode = errorCode;
    this.errorParameter = errorParameter;
  }
&nbsp;
  public ArgsException(ErrorCode errorCode, 
                       char errorArgumentId, String errorParameter) {
    this.errorCode = errorCode;
    this.errorParameter = errorParameter;
    this.errorArgumentId = errorArgumentId;
  }
&nbsp;
  public char getErrorArgumentId() {
    return errorArgumentId;
  }
&nbsp;
  public void setErrorArgumentId(char errorArgumentId) {
    this.errorArgumentId = errorArgumentId;
  }
&nbsp;
  public String getErrorParameter() {
    return errorParameter;
  }
&nbsp;
  public void setErrorParameter(String errorParameter) {
    this.errorParameter = errorParameter;
  }
&nbsp;
  public ErrorCode getErrorCode() {
    return errorCode;
  }
&nbsp;
  public void setErrorCode(ErrorCode errorCode) {
    this.errorCode = errorCode;
  }
&nbsp;
  public String errorMessage() {
    switch (errorCode) {
      case OK:
        return â€œTILT: Should not get here.â€;
      case UNEXPECTED_ARGUMENT:
        return String.format(â€œArgument -%c unexpected.â€, errorArgumentId);
      case MISSING_STRING:
        return String.format(â€œCould not find string parameter for -%c.â€, 
                              errorArgumentId);
      case INVALID_INTEGER:
        return String.format(â€œArgument -%c expects an integer but was â€™%sâ€™.â€, 
                              errorArgumentId, errorParameter);
      case MISSING_INTEGER:
        return String.format(â€œCould not find integer parameter for -%c.â€,
                              errorArgumentId);
      case INVALID_DOUBLE:
        return String.format(â€œArgument -%c expects a double but was â€™%sâ€™.â€, 
                              errorArgumentId, errorParameter);
      case MISSING_DOUBLE:
        return String.format(â€œCould not find double parameter for -%c.â€, 
                              errorArgumentId);
      case INVALID_ARGUMENT_NAME:
        return String.format(â€œâ€™%câ€ is not a valid argument name.â€, 
                              errorArgumentId);
      case INVALID_ARGUMENT_FORMAT:
        return String.format(â€œâ€™%sâ€ is not a valid argument format.â€, 
                              errorParameter);
    }
    return â€â€;
  }
&nbsp;
  public enum ErrorCode {
    OK, INVALID_ARGUMENT_FORMAT, UNEXPECTED_ARGUMENT, INVALID_ARGUMENT_NAME,
    MISSING_STRING,
    MISSING_INTEGER, INVALID_INTEGER,
    MISSING_DOUBLE, INVALID_DOUBLE}
}
</code></pre>
</div>
<p>It got issues:</p>
<ul>
<li>Reintroduces error codes inside exceptions (contradicting the book's own advice). <br/>
This book mentions 2 times that it's preferrable to use exceptions instead of error codes. And yet in the example he is introducing error codes inside exceptions.
Why?
Imagine if there was a tool that would allow to document such design decisions in code.. That would be so convinient. Unfortunately this tool doesn't exist. /s</li>
<li>Has weirdly specific error types (why MISSING_DOUBLE and MISSING_INTEGER are separate?)</li>
<li>Has an ErrorCode.OK which makes no sense (what does this mean <code>throw new ArgsException(ErrorCode.OK)</code>?)</li>
<li>The exception is mutable. It lets you change error details after creating the exception (why?)</li>
</ul>
<h2 id="the-tdd-problem"><a class="header" href="#the-tdd-problem">The TDD Problem</a></h2>
<p>The chapter shows TDD in action, revealing two problems:</p>
<ol>
<li>Focus on small steps can miss big-picture issues</li>
<li>Starting point heavily influences final quality</li>
</ol>
<p>Martin began with deeply problematic code:</p>
<ul>
<li>Lots of tiny methods</li>
<li>Huge area of mutable state</li>
<li>Everything crammed into one class</li>
</ul>
<div class="book-quote">
<pre><code class="language-java">public class Args {
  private String schema;
  private String[] args;
  private boolean valid = true;
  private Set&lt;Character&gt; unexpectedArguments = new TreeSet&lt;Character&gt;();
  private Map&lt;Character, Boolean&gt; booleanArgs = new HashMap&lt;Character, Boolean&gt;();
  private Map&lt;Character, String&gt; stringArgs = new HashMap&lt;Character, String&gt;();
  private Map&lt;Character, Integer&gt; intArgs = new HashMap&ltCharacter, Integer&gt;();
  private Set&lt;Character&gt; argsFound = new HashSet&lt;Character&gt;();
  private int currentArgument;
  private char errorArgumentId = â€™\0â€™;
  private String errorParameter = â€œTILTâ€;
  private ErrorCode errorCode = ErrorCode.OK;
&nbsp;
  private enum ErrorCode {
    OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT}
&nbsp;
  public Args(String schema, String[] args) throws ParseException {
    this.schema = schema;
    this.args = args;
    valid = parse();
  }
&nbsp;
  private boolean parse() throws ParseException {
    if (schema.length() == 0 && args.length == 0)
      return true;
    parseSchema();
    try {
      parseArguments();
    } catch (ArgsException e) {
    }
    return valid;
  }
&nbsp;
  private boolean parseSchema() throws ParseException {
    for (String element : schema.split(â€œ,â€)) {
      if (element.length() > 0) {
        String trimmedElement = element.trim();
        parseSchemaElement(trimmedElement);
      }
    }
    return true;
  }
&nbsp;
  private void parseSchemaElement(String element) throws ParseException {
    char elementId = element.charAt(0);
    String elementTail = element.substring(1);
    validateSchemaElementId(elementId);
    if (isBooleanSchemaElement(elementTail))
      parseBooleanSchemaElement(elementId);
    else if (isStringSchemaElement(elementTail))
      parseStringSchemaElement(elementId);
    else if (isIntegerSchemaElement(elementTail)) {
      parseIntegerSchemaElement(elementId);
    } else {
      throw new ParseException(
        String.format(â€œArgument: %c has invalid format: %s.â€, 
                     elementId, elementTail), 0);
    }
  }
&nbsp;
  private void validateSchemaElementId(char elementId) throws ParseException {
    if (!Character.isLetter(elementId)) {
      throw new ParseException(
        â€œBad character:â€ + elementId + â€œin Args format: â€ + schema, 0);
    }
  }
&nbsp;
  private void parseBooleanSchemaElement(char elementId) {
    booleanArgs.put(elementId, false);
  }
&nbsp;
  private void parseIntegerSchemaElement(char elementId) {
    intArgs.put(elementId, 0);
  }
&nbsp;
  private void parseStringSchemaElement(char elementId) {
    stringArgs.put(elementId, â€â€);
  }
&nbsp;
  private boolean isStringSchemaElement(String elementTail) {
    return elementTail.equals(â€*â€);
  }
&nbsp;
  private boolean isBooleanSchemaElement(String elementTail) {
    return elementTail.length() == 0;
  }
&nbsp;
  private boolean isIntegerSchemaElement(String elementTail) {
    return elementTail.equals(â€#â€);
  }
&nbsp;
  private boolean parseArguments() throws ArgsException {
    for (currentArgument = 0; currentArgument < args.length; currentArgument++) {
      String arg = args[currentArgument];
      parseArgument(arg);
    }
    return true;
  }
&nbsp;
  private void parseArgument(String arg) throws ArgsException {
    if (arg.startsWith(â€-â€))
      parseElements(arg);
  }
&nbsp;
  private void parseElements(String arg) throws ArgsException {
    for (int i = 1; i < arg.length(); i++)
      parseElement(arg.charAt(i));
  }
&nbsp;
  private void parseElement(char argChar) throws ArgsException {
    if (setArgument(argChar))
      argsFound.add(argChar);
    else {
      unexpectedArguments.add(argChar);
      errorCode = ErrorCode.UNEXPECTED_ARGUMENT;
      valid = false;
    }
  }
&nbsp;
  private boolean setArgument(char argChar) throws ArgsException {
    if (isBooleanArg(argChar))
      setBooleanArg(argChar, true);
    else if (isStringArg(argChar))
      setStringArg(argChar);
    else if (isIntArg(argChar))
      setIntArg(argChar);
    else
      return false;
&nbsp;
    return true;
  }
&nbsp;
  private boolean isIntArg(char argChar) {return intArgs.containsKey(argChar);}
&nbsp;
  private void setIntArg(char argChar) throws ArgsException {
    currentArgument++;
    String parameter = null;
    try {
      parameter = args[currentArgument];
      intArgs.put(argChar, new Integer(parameter));
    } catch (ArrayIndexOutOfBoundsException e) {
      valid = false;
      errorArgumentId = argChar;
      errorCode = ErrorCode.MISSING_INTEGER;
&nbsp;
      throw new ArgsException();
    } catch (NumberFormatException e) {
      valid = false;
      errorArgumentId = argChar;
      errorParameter = parameter;
      errorCode = ErrorCode.INVALID_INTEGER;
      throw new ArgsException();
    }
  }
&nbsp;
  private void setStringArg(char argChar) throws ArgsException {
    currentArgument++;
    try {
      stringArgs.put(argChar, args[currentArgument]);
    } catch (ArrayIndexOutOfBoundsException e) {
      valid = false;
      errorArgumentId = argChar;
      errorCode = ErrorCode.MISSING_STRING;
      throw new ArgsException();
    }
  }
&nbsp;
  private boolean isStringArg(char argChar) {
    return stringArgs.containsKey(argChar);
  }
&nbsp;
  private void setBooleanArg(char argChar, boolean value) {
    booleanArgs.put(argChar, value);
  }
&nbsp;
  private boolean isBooleanArg(char argChar) {
    return booleanArgs.containsKey(argChar);
  }
&nbsp;
  public int cardinality() {
    return argsFound.size();
  }
&nbsp;
  public String usage() {
    if (schema.length() > 0)
      return â€œ-[â€ + schema + â€œ]â€;
    else
      return â€â€;
  }
&nbsp;
  public String errorMessage() throws Exception {
    switch (errorCode) {
      case OK:
        throw new Exception(â€œTILT: Should not get here.â€);
      case UNEXPECTED_ARGUMENT:
        return unexpectedArgumentMessage();
      case MISSING_STRING:
        return String.format(â€œCould not find string parameter for -%c.â€,
                            errorArgumentId);
&nbsp;
      case INVALID_INTEGER:
        return String.format(â€œArgument -%c expects an integer but was â€™%sâ€™.â€, 
                            errorArgumentId, errorParameter);
      case MISSING_INTEGER:
        return String.format(â€œCould not find integer parameter for -%c.â€, 
                            errorArgumentId);
    }
    return â€â€;
  }
&nbsp;
  private String unexpectedArgumentMessage() {
    StringBuffer message = new StringBuffer(â€œArgument(s) -â€);
    for (char c : unexpectedArguments) {
      message.append(c);
    }
    message.append(â€œ unexpected.â€);
&nbsp;
    return message.toString();
  }
&nbsp;
  private boolean falseIfNull(Boolean b) {
    return b != null && b;
  }
&nbsp;
  private int zeroIfNull(Integer i) {
    return i == null ? 0 : i;
  }
&nbsp;
  private String blankIfNull(String s) {
    return s == null ? â€â€ : s;
  }
&nbsp;
  public String getString(char arg) {
    return blankIfNull(stringArgs.get(arg));
  }
&nbsp;
  public int getInt(char arg) {
    return zeroIfNull(intArgs.get(arg));
  }
&nbsp;
  public boolean getBoolean(char arg) {
    return falseIfNull(booleanArgs.get(arg));
  }
&nbsp;
  public boolean has(char arg) {
    return argsFound.contains(arg);
  }
&nbsp;
  public boolean isValid() {
    return valid;
  }
&nbsp;
  private class ArgsException extends Exception {
  }
}
</code></pre>
</div>
<p>:shrug emoji: No wonder it would require him a lot of steps to end up on something more reasonable.</p>
<p>If you ask claude sonnet 3.5:</p>
<pre><code>Create a mini library to parse command line arguments. It should support following API:

Args arg = new Args(â€œl,p#,d*â€, args);
boolean logging = arg.getBoolean(â€™lâ€™);
int port = arg.getInt(â€™pâ€™);
String directory = arg.getString(â€™dâ€™);
</code></pre>
<p>It would come up with pretty reasonable draft:</p>
<pre><code class="language-java">public class Args {
    private Map&lt;Character, String&gt; schema = new HashMap&lt;&gt;();
    private Map&lt;Character, String&gt; parsedArguments = new HashMap&lt;&gt;();

    public Args(String schema, String[] args) throws IllegalArgumentException {
        parseSchema(schema);
        parseArgs(args);
    }

    private void parseSchema(String schema) throws IllegalArgumentException {
        String[] schemaParts = schema.split(",");
        for (String part : schemaParts) {
            if (part.length() &lt; 1) {
                throw new IllegalArgumentException("Invalid schema format");
            }
            char flag = part.charAt(0);
            String type = part.length() &gt; 1 ? part.substring(1) : "";
            
            if (!type.matches("^[#*]?$")) {
                throw new IllegalArgumentException("Invalid type specifier for flag: " + flag);
            }
            
            schema.put(flag, type);
        }
    }

    private void parseArgs(String[] args) throws IllegalArgumentException {
        for (int i = 0; i &lt; args.length; i++) {
            String arg = args[i];
            if (!arg.startsWith("-") || arg.length() != 2) {
                throw new IllegalArgumentException("Invalid argument format: " + arg);
            }

            char flag = arg.charAt(1);
            if (!schema.containsKey(flag)) {
                throw new IllegalArgumentException("Unknown flag: " + flag);
            }

            String type = schema.get(flag);
            if (type.isEmpty()) {  // boolean flag
                parsedArguments.put(flag, "true");
            } else {  // string or integer flag
                if (i + 1 &gt;= args.length) {
                    throw new IllegalArgumentException("No value provided for flag: " + flag);
                }
                parsedArguments.put(flag, args[++i]);
            }
        }
    }

    public boolean getBoolean(char flag) throws IllegalArgumentException {
        validateFlag(flag, "");
        return parsedArguments.containsKey(flag);
    }

    public int getInt(char flag) throws IllegalArgumentException {
        validateFlag(flag, "#");
        try {
            return Integer.parseInt(parsedArguments.getOrDefault(flag, "0"));
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException("Invalid integer value for flag: " + flag);
        }
    }

    public String getString(char flag) throws IllegalArgumentException {
        validateFlag(flag, "*");
        return parsedArguments.getOrDefault(flag, "");
    }

    private void validateFlag(char flag, String expectedType) throws IllegalArgumentException {
        if (!schema.containsKey(flag)) {
            throw new IllegalArgumentException("Unknown flag: " + flag);
        }
        if (!schema.get(flag).equals(expectedType)) {
            throw new IllegalArgumentException("Invalid type for flag: " + flag);
        }
    }
}
</code></pre>
<p>Not perfect, but a much better starting point for discussions about:</p>
<ul>
<li>How to make it easier to add new types</li>
<li>How to improve the schema format</li>
<li>How to make errors more specific</li>
</ul>
<p>The chapter unintentionally demonstrates how TDD alone doesn't guarantee good design - you need solid architectural vision too.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/book2.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
