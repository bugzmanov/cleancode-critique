<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 14: Successive Refinement - Clean Code - Critical Analysis</title>


        <!-- Custom HTML head -->
        <!-- Basic SEO Meta Tags -->
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="title" content="Clean Code - A Critical Analysis">
        <meta name="description" content="A modern critique of Robert C. Martin's Clean Code. This book evaluates its principles, explores real-world software development challenges, and presents alternative approaches to writing maintainable code.">
        <meta name="keywords" content="Clean Code, software development, coding best practices, refactoring, code readability, programming critique">
        <meta name="author" content="bugzmanov">
        <meta name="robots" content="index, follow">
        
        <!-- Open Graph (OG) Meta Tags for Social Media -->
        <meta property="og:title" content="Clean Code - A Critical Analysis">
        <meta property="og:description" content="A deep dive into Clean Code's impact, its shortcomings, and what modern developers should do instead.">
        <meta property="og:type" content="book">
        <meta property="og:url" content="https://bugzmanov.github.io/cleancode-critique/">
        <meta property="og:image" content="https://bugzmanov.github.io/cleancode-critique/images/is_this_code_clean.png">
        
        <!-- Twitter Card Meta Tags -->
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" content="Clean Code - A Critical Analysis">
        <meta name="twitter:description" content="A modern critique of Clean Code, evaluating its relevance and offering alternative programming best practices.">
        <meta name="twitter:image" content="https://bugzmanov.github.io/cleancode-critique/images/is_this_code_clean.png">
        <meta name="twitter:site" content="@bugzmanov">
        
        <!-- Canonical URL -->
        <link rel="canonical" href="https://bugzmanov.github.io/cleancode-critique/">
        
        <!-- Favicon -->
        <link rel="icon" type="image/png" href="https://bugzmanov.github.io/cleancode-critique/favicon.svg">
        

        <meta name="description" content="A modern critique of Robert C. Martin&#x27;s &#x27;Clean Code,&#x27; evaluating its principles, real-world applicability, and alternative approaches to software development. This book explores the nuances of code quality, refactoring strategies, and the evolution of programming best practices beyond Clean Code&#x27;s rigid rules.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/custom.css">
        <link rel="stylesheet" href="theme/css/custom-flex.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Clean Code - Critical Analysis</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/buhzmanov/cleancode-critique" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-14-successive-refinement"><a class="header" href="#chapter-14-successive-refinement">Chapter 14: Successive Refinement</a></h1>
<p>This chapter is an example of how he arrives to "clean code" solution for a specific task.</p>
<p>When I first read the book in 2009 I loved it.
It felt like the best programming book.
But even then, this chapter left me with an uneasy feeling about his solution. I spent a lot of time re-reading it, thinking I was too junior to understand why it was good.
15 years later I still don't like his solution, but now I can explain why.</p>
<p>The task: create a command-line argument parser with this interface:</p>
<div class="book-quote">
<pre><code class="language-java">public static void main(String[] args) {
    try {
        Args arg = new Args("l,p#,d*", args);
        boolean logging = arg.getBoolean('l');
        int port = arg.getInt('p');
        String directory = arg.getString('d');
        executeApplication(logging, port, directory);
    } catch (ArgsException e) {
        System.out.printf("Argument error: %s\n", e.errorMessage());
    }
}
</code></pre>
</div>
<p>This is the solution that Martin is proud of and insists that it needs to be carefully studied:</p>
<div class="book-quote">
<pre><code class="language-java">package com.objectmentor.utilities.args;
&nbsp;
import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;
import java.util.*;
&nbsp;
public class Args {
    private Map&lt;Character, ArgumentMarshaler&gt; marshalers;
    private Set&lt;Character&gt; argsFound;
    private ListIterator&lt;String&gt; currentArgument;
&nbsp;
    public Args(String schema, String[] args) throws ArgsException {
        marshalers = new HashMap&lt;Character, ArgumentMarshaler&gt;();
        argsFound = new HashSet&lt;Character&gt;();
&nbsp;
        parseSchema(schema);
        parseArgumentStrings(Arrays.asList(args));
    }
&nbsp;
    private void parseSchema(String schema) throws ArgsException {
        for (String element : schema.split(“,”))
            if (element.length() > 0)
                parseSchemaElement(element.trim());
    }
&nbsp;
    private void parseSchemaElement(String element) throws ArgsException {
        char elementId = element.charAt(0);
        String elementTail = element.substring(1);
        validateSchemaElementId(elementId);
        if (elementTail.length() == 0)
            marshalers.put(elementId, new BooleanArgumentMarshaler());
        else if (elementTail.equals(“*”))
            marshalers.put(elementId, new StringArgumentMarshaler());
        else if (elementTail.equals(“#”))
            marshalers.put(elementId, new IntegerArgumentMarshaler());
        else if (elementTail.equals(“##”))
            marshalers.put(elementId, new DoubleArgumentMarshaler());
        else if (elementTail.equals(“[*]”))
            marshalers.put(elementId, new StringArrayArgumentMarshaler());
        else
            throw new ArgsException(INVALID_ARGUMENT_FORMAT, elementId, elementTail);
    }
&nbsp;
    private void validateSchemaElementId(char elementId) throws ArgsException {
        if (!Character.isLetter(elementId))
            throw new ArgsException(INVALID_ARGUMENT_NAME, elementId, null);
    }
&nbsp;
    private void parseArgumentStrings(List&lt;String&gt; argsList) throws ArgsException 
    {
        for (currentArgument = argsList.listIterator(); currentArgument.hasNext();) 
        {
            String argString = currentArgument.next();
            if (argString.startsWith(“-”)) {
                parseArgumentCharacters(argString.substring(1));
            } else {
                currentArgument.previous();
                break;
            }
        }
    }
&nbsp;
    private void parseArgumentCharacters(String argChars) throws ArgsException {
        for (int i = 0; i < argChars.length(); i++)
            parseArgumentCharacter(argChars.charAt(i));
    }
&nbsp;
    private void parseArgumentCharacter(char argChar) throws ArgsException {
        ArgumentMarshaler m = marshalers.get(argChar);
        if (m == null) {
            throw new ArgsException(UNEXPECTED_ARGUMENT, argChar, null);
        } else {
            argsFound.add(argChar);
            try {
                m.set(currentArgument);
            } catch (ArgsException e) {
                e.setErrorArgumentId(argChar);
                throw e;
            }
        }
    }
&nbsp;
    public boolean has(char arg) {
        return argsFound.contains(arg);
    }
&nbsp;
    public int nextArgument() {
        return currentArgument.nextIndex();
    }
&nbsp;
    public boolean getBoolean(char arg) {
        return BooleanArgumentMarshaler.getValue(marshalers.get(arg));
    }
&nbsp;
    public String getString(char arg) {
        return StringArgumentMarshaler.getValue(marshalers.get(arg));
    }
&nbsp;
    public int getInt(char arg) {
        return IntegerArgumentMarshaler.getValue(marshalers.get(arg));
    }
&nbsp;
    public double getDouble(char arg) {
        return DoubleArgumentMarshaler.getValue(marshalers.get(arg));
    }
&nbsp;
    public String[] getStringArray(char arg) {
        return StringArrayArgumentMarshaler.getValue(marshalers.get(arg));
    }
}
&nbsp;
//....
&nbsp;
public class StringArgumentMarshaler implements ArgumentMarshaler {
  private String stringValue = null;
&nbsp;
  public void set(Iterator<String> currentArgument) throws ArgsException {
    try {
      stringValue = currentArgument.next();
    } catch (NoSuchElementException e) {
      throw new ArgsException(MISSING_STRING);
    }
  }
&nbsp;
  public static String getValue(ArgumentMarshaler am) {
    if (am != null && am instanceof StringArgumentMarshaler)
      return ((StringArgumentMarshaler) am).stringValue;
    else
      return ””;
  }
}
</code></pre>
</div>
<h2 id="the-problems"><a class="header" href="#the-problems">The Problems</a></h2>
<h3 id="1-weird-interface-design"><a class="header" href="#1-weird-interface-design">1. Weird Interface Design</a></h3>
<p>Look at StringArgumentMarshaler:</p>
<div class="book-quote">
<pre><code class="language-java">public class StringArgumentMarshaler implements ArgumentMarshaler {
  private String stringValue = null;
&nbsp;
  public void set(Iterator&lt;String&gt; currentArgument) throws ArgsException {
    try {
      stringValue = currentArgument.next();
    } catch (NoSuchElementException e) {
      throw new ArgsException(MISSING_STRING);
    }
  }
&nbsp;
  public static String getValue(ArgumentMarshaler am) {
    if (am != null && am instanceof StringArgumentMarshaler)
      return ((StringArgumentMarshaler) am).stringValue;
    else
      return "";
  }
}</code></pre>
</div>
<p><code>set</code> is an instance method but <code>getValue</code> is static. Why not take a simpler approach?</p>
<pre><code class="language-java">public interface ArgumentMarshaler&lt;T&gt; {
    void set(Iterator&lt;String&gt; currentArgument) throws ArgsException;
    Optional&lt;T&gt; get();
}
</code></pre>
<h3 id="2-mixed-up-responsibilities"><a class="header" href="#2-mixed-up-responsibilities">2. Mixed Up Responsibilities</a></h3>
<p>The StringArgumentMarshaler (and all other marshalers) tries to do two things:</p>
<ul>
<li>Parse token streams</li>
<li>Store and provide parsed values</li>
</ul>
<p>From an interface design perspective, this would make more sense:</p>
<pre><code class="language-java">public interface ArgumentParser&lt;T&gt; {
    T parse(Iterator&lt;String&gt; currentArgument) throws ArgsException;
}
</code></pre>
<h3 id="3-messy-error-handling"><a class="header" href="#3-messy-error-handling">3. Messy Error Handling</a></h3>
<p>The <code>set</code> method does some validation, but <code>get</code> just falls back to type-specific default values if something's wrong.
Silent failures with default values can lead to subtle bugs.</p>
<p>Check out how the IntegerArgumentMarshaler assumes 0 is a safe default:</p>
<div class="book-quote">
<pre><code class="language-java">public static int getValue(ArgumentMarshaler am) {
    if (am != null && am instanceof IntegerArgumentMarshaler)
        return ((IntegerArgumentMarshaler) am).intValue;
    else
        return 0;
}
</code></pre>
</div>
<p>Here's how this can bite you:</p>
<pre><code class="language-java">Args arg = new Args("l,p#,p*", args); // p is marked as string here
int port = arg.getInt('p');           // but trying to read as int
</code></pre>
<p>The library quietly gives you 0 as the port value, which is extra bad since <a href="https://www.lifewire.com/port-0-in-tcp-and-udp-818145">port 0 means something special in Unix</a>.</p>
<p>The argument parsing library is expected to be generic - i.e. it's expected to be used in wide range of domains.<br/>
In this context, it is not safe to assume default values based on type information alone.</p>
<h3 id="4-state-management-gone-wrong"><a class="header" href="#4-state-management-gone-wrong">4. State Management Gone Wrong</a></h3>
<p>The Args class mixes up final results and intermediate processing state in the same scope, while keeping the state it doesn't need:</p>
<div class="book-quote">
<pre><code class="language-java">public class Args {
    private Map&lt;Character, ArgumentMarshaler&gt; marshalers;  // This has the final results
    private Set&lt;Character&gt; argsFound;                      // Don't need this, can get from marshalers
    private ListIterator&lt;String&gt; currentArgument;          // Only needed during parsing
</code></pre>
</div>
<h3 id="5-overcomplicated-errors"><a class="header" href="#5-overcomplicated-errors">5. Overcomplicated Errors</a></h3>
<p>Let's talk about that ArgsException class.</p>
<div class="book-quote">
<pre><code class="language-java">public class ArgsException extends Exception {
  private char errorArgumentId = ’\0’;
  private String errorParameter = null;
  private ErrorCode errorCode = OK;
&nbsp;
  public ArgsException() {}
&nbsp;
  public ArgsException(String message) {super(message);}
&nbsp;
  public ArgsException(ErrorCode errorCode) {
    this.errorCode = errorCode;
  }
&nbsp;
  public ArgsException(ErrorCode errorCode, String errorParameter) {
    this.errorCode = errorCode;
    this.errorParameter = errorParameter;
  }
&nbsp;
  public ArgsException(ErrorCode errorCode, 
                       char errorArgumentId, String errorParameter) {
    this.errorCode = errorCode;
    this.errorParameter = errorParameter;
    this.errorArgumentId = errorArgumentId;
  }
&nbsp;
  public char getErrorArgumentId() {
    return errorArgumentId;
  }
&nbsp;
  public void setErrorArgumentId(char errorArgumentId) {
    this.errorArgumentId = errorArgumentId;
  }
&nbsp;
  public String getErrorParameter() {
    return errorParameter;
  }
&nbsp;
  public void setErrorParameter(String errorParameter) {
    this.errorParameter = errorParameter;
  }
&nbsp;
  public ErrorCode getErrorCode() {
    return errorCode;
  }
&nbsp;
  public void setErrorCode(ErrorCode errorCode) {
    this.errorCode = errorCode;
  }
&nbsp;
  public String errorMessage() {
    switch (errorCode) {
      case OK:
        return “TILT: Should not get here.”;
      case UNEXPECTED_ARGUMENT:
        return String.format(“Argument -%c unexpected.”, errorArgumentId);
      case MISSING_STRING:
        return String.format(“Could not find string parameter for -%c.”, 
                              errorArgumentId);
      case INVALID_INTEGER:
        return String.format(“Argument -%c expects an integer but was ’%s’.”, 
                              errorArgumentId, errorParameter);
      case MISSING_INTEGER:
        return String.format(“Could not find integer parameter for -%c.”,
                              errorArgumentId);
      case INVALID_DOUBLE:
        return String.format(“Argument -%c expects a double but was ’%s’.”, 
                              errorArgumentId, errorParameter);
      case MISSING_DOUBLE:
        return String.format(“Could not find double parameter for -%c.”, 
                              errorArgumentId);
      case INVALID_ARGUMENT_NAME:
        return String.format(“’%c” is not a valid argument name.”, 
                              errorArgumentId);
      case INVALID_ARGUMENT_FORMAT:
        return String.format(“’%s” is not a valid argument format.”, 
                              errorParameter);
    }
    return ””;
  }
&nbsp;
  public enum ErrorCode {
    OK, INVALID_ARGUMENT_FORMAT, UNEXPECTED_ARGUMENT, INVALID_ARGUMENT_NAME,
    MISSING_STRING,
    MISSING_INTEGER, INVALID_INTEGER,
    MISSING_DOUBLE, INVALID_DOUBLE}
}
</code></pre>
</div>
<p>It got issues:</p>
<ul>
<li>Reintroduces error codes inside exceptions (contradicting the book's own advice). <br/>
This book mentions 2 times that it's preferrable to use exceptions instead of error codes. And yet in the example he is introducing error codes inside exceptions.
Why?
Imagine if there was a tool that would allow to document such design decisions in code.. That would be so convinient. Unfortunately this tool doesn't exist. /s</li>
<li>Has weirdly specific error types (why MISSING_DOUBLE and MISSING_INTEGER are separate?)</li>
<li>Has an ErrorCode.OK which makes no sense (what does this mean to <code>throw new ArgsException(ErrorCode.OK)</code>?)</li>
<li>The exception is mutable. It lets you change error details after creating the exception (why?)</li>
</ul>
<h2 id="the-tdd-problem"><a class="header" href="#the-tdd-problem">The TDD Problem</a></h2>
<p>The chapter shows TDD in action, revealing two problems:</p>
<ol>
<li>Focus on small steps can miss big-picture issues</li>
<li>Starting point heavily influences final quality</li>
</ol>
<p>Martin began with deeply problematic code:</p>
<ul>
<li>Lots of tiny methods</li>
<li>Huge area of mutable state</li>
<li>Everything crammed into one class</li>
</ul>
<div class="book-quote">
<pre><code class="language-java">public class Args {
  private String schema;
  private String[] args;
  private boolean valid = true;
  private Set&lt;Character&gt; unexpectedArguments = new TreeSet&lt;Character&gt;();
  private Map&lt;Character, Boolean&gt; booleanArgs = new HashMap&lt;Character, Boolean&gt;();
  private Map&lt;Character, String&gt; stringArgs = new HashMap&lt;Character, String&gt;();
  private Map&lt;Character, Integer&gt; intArgs = new HashMap&ltCharacter, Integer&gt;();
  private Set&lt;Character&gt; argsFound = new HashSet&lt;Character&gt;();
  private int currentArgument;
  private char errorArgumentId = ’\0’;
  private String errorParameter = “TILT”;
  private ErrorCode errorCode = ErrorCode.OK;
&nbsp;
  private enum ErrorCode {
    OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT}
&nbsp;
  public Args(String schema, String[] args) throws ParseException {
    this.schema = schema;
    this.args = args;
    valid = parse();
  }
&nbsp;
  private boolean parse() throws ParseException {
    if (schema.length() == 0 && args.length == 0)
      return true;
    parseSchema();
    try {
      parseArguments();
    } catch (ArgsException e) {
    }
    return valid;
  }
&nbsp;
  private boolean parseSchema() throws ParseException {
    for (String element : schema.split(“,”)) {
      if (element.length() > 0) {
        String trimmedElement = element.trim();
        parseSchemaElement(trimmedElement);
      }
    }
    return true;
  }
&nbsp;
  private void parseSchemaElement(String element) throws ParseException {
    char elementId = element.charAt(0);
    String elementTail = element.substring(1);
    validateSchemaElementId(elementId);
    if (isBooleanSchemaElement(elementTail))
      parseBooleanSchemaElement(elementId);
    else if (isStringSchemaElement(elementTail))
      parseStringSchemaElement(elementId);
    else if (isIntegerSchemaElement(elementTail)) {
      parseIntegerSchemaElement(elementId);
    } else {
      throw new ParseException(
        String.format(“Argument: %c has invalid format: %s.”, 
                     elementId, elementTail), 0);
    }
  }
&nbsp;
  private void validateSchemaElementId(char elementId) throws ParseException {
    if (!Character.isLetter(elementId)) {
      throw new ParseException(
        “Bad character:” + elementId + “in Args format: ” + schema, 0);
    }
  }
&nbsp;
  private void parseBooleanSchemaElement(char elementId) {
    booleanArgs.put(elementId, false);
  }
&nbsp;
  private void parseIntegerSchemaElement(char elementId) {
    intArgs.put(elementId, 0);
  }
&nbsp;
  private void parseStringSchemaElement(char elementId) {
    stringArgs.put(elementId, ””);
  }
&nbsp;
  private boolean isStringSchemaElement(String elementTail) {
    return elementTail.equals(”*”);
  }
&nbsp;
  private boolean isBooleanSchemaElement(String elementTail) {
    return elementTail.length() == 0;
  }
&nbsp;
  private boolean isIntegerSchemaElement(String elementTail) {
    return elementTail.equals(”#”);
  }
&nbsp;
  private boolean parseArguments() throws ArgsException {
    for (currentArgument = 0; currentArgument < args.length; currentArgument++) {
      String arg = args[currentArgument];
      parseArgument(arg);
    }
    return true;
  }
&nbsp;
  private void parseArgument(String arg) throws ArgsException {
    if (arg.startsWith(”-”))
      parseElements(arg);
  }
&nbsp;
  private void parseElements(String arg) throws ArgsException {
    for (int i = 1; i < arg.length(); i++)
      parseElement(arg.charAt(i));
  }
&nbsp;
  private void parseElement(char argChar) throws ArgsException {
    if (setArgument(argChar))
      argsFound.add(argChar);
    else {
      unexpectedArguments.add(argChar);
      errorCode = ErrorCode.UNEXPECTED_ARGUMENT;
      valid = false;
    }
  }
&nbsp;
  private boolean setArgument(char argChar) throws ArgsException {
    if (isBooleanArg(argChar))
      setBooleanArg(argChar, true);
    else if (isStringArg(argChar))
      setStringArg(argChar);
    else if (isIntArg(argChar))
      setIntArg(argChar);
    else
      return false;
&nbsp;
    return true;
  }
&nbsp;
  private boolean isIntArg(char argChar) {return intArgs.containsKey(argChar);}
&nbsp;
  private void setIntArg(char argChar) throws ArgsException {
    currentArgument++;
    String parameter = null;
    try {
      parameter = args[currentArgument];
      intArgs.put(argChar, new Integer(parameter));
    } catch (ArrayIndexOutOfBoundsException e) {
      valid = false;
      errorArgumentId = argChar;
      errorCode = ErrorCode.MISSING_INTEGER;
&nbsp;
      throw new ArgsException();
    } catch (NumberFormatException e) {
      valid = false;
      errorArgumentId = argChar;
      errorParameter = parameter;
      errorCode = ErrorCode.INVALID_INTEGER;
      throw new ArgsException();
    }
  }
&nbsp;
  private void setStringArg(char argChar) throws ArgsException {
    currentArgument++;
    try {
      stringArgs.put(argChar, args[currentArgument]);
    } catch (ArrayIndexOutOfBoundsException e) {
      valid = false;
      errorArgumentId = argChar;
      errorCode = ErrorCode.MISSING_STRING;
      throw new ArgsException();
    }
  }
&nbsp;
  private boolean isStringArg(char argChar) {
    return stringArgs.containsKey(argChar);
  }
&nbsp;
  private void setBooleanArg(char argChar, boolean value) {
    booleanArgs.put(argChar, value);
  }
&nbsp;
  private boolean isBooleanArg(char argChar) {
    return booleanArgs.containsKey(argChar);
  }
&nbsp;
  public int cardinality() {
    return argsFound.size();
  }
&nbsp;
  public String usage() {
    if (schema.length() > 0)
      return “-[” + schema + “]”;
    else
      return ””;
  }
&nbsp;
  public String errorMessage() throws Exception {
    switch (errorCode) {
      case OK:
        throw new Exception(“TILT: Should not get here.”);
      case UNEXPECTED_ARGUMENT:
        return unexpectedArgumentMessage();
      case MISSING_STRING:
        return String.format(“Could not find string parameter for -%c.”,
                            errorArgumentId);
&nbsp;
      case INVALID_INTEGER:
        return String.format(“Argument -%c expects an integer but was ’%s’.”, 
                            errorArgumentId, errorParameter);
      case MISSING_INTEGER:
        return String.format(“Could not find integer parameter for -%c.”, 
                            errorArgumentId);
    }
    return ””;
  }
&nbsp;
  private String unexpectedArgumentMessage() {
    StringBuffer message = new StringBuffer(“Argument(s) -”);
    for (char c : unexpectedArguments) {
      message.append(c);
    }
    message.append(“ unexpected.”);
&nbsp;
    return message.toString();
  }
&nbsp;
  private boolean falseIfNull(Boolean b) {
    return b != null && b;
  }
&nbsp;
  private int zeroIfNull(Integer i) {
    return i == null ? 0 : i;
  }
&nbsp;
  private String blankIfNull(String s) {
    return s == null ? ”” : s;
  }
&nbsp;
  public String getString(char arg) {
    return blankIfNull(stringArgs.get(arg));
  }
&nbsp;
  public int getInt(char arg) {
    return zeroIfNull(intArgs.get(arg));
  }
&nbsp;
  public boolean getBoolean(char arg) {
    return falseIfNull(booleanArgs.get(arg));
  }
&nbsp;
  public boolean has(char arg) {
    return argsFound.contains(arg);
  }
&nbsp;
  public boolean isValid() {
    return valid;
  }
&nbsp;
  private class ArgsException extends Exception {
  }
}
</code></pre>
</div>
<p>:shrug emoji: No wonder it would require him a lot of steps to end up on something more reasonable.</p>
<p>If you ask claude sonnet 3.5:</p>
<pre><code>Create a mini library to parse command line arguments. It should support following API:

Args arg = new Args(“l,p#,d*”, args);
boolean logging = arg.getBoolean(’l’);
int port = arg.getInt(’p’);
String directory = arg.getString(’d’);
</code></pre>
<p>It would come up with pretty reasonable draft:</p>
<pre><code class="language-java">public class Args {
    private Map&lt;Character, String&gt; schema = new HashMap&lt;&gt;();
    private Map&lt;Character, String&gt; parsedArguments = new HashMap&lt;&gt;();

    public Args(String schema, String[] args) throws IllegalArgumentException {
        parseSchema(schema);
        parseArgs(args);
    }

    private void parseSchema(String schema) throws IllegalArgumentException {
        String[] schemaParts = schema.split(",");
        for (String part : schemaParts) {
            if (part.length() &lt; 1) {
                throw new IllegalArgumentException("Invalid schema format");
            }
            char flag = part.charAt(0);
            String type = part.length() &gt; 1 ? part.substring(1) : "";
            
            if (!type.matches("^[#*]?$")) {
                throw new IllegalArgumentException("Invalid type specifier for flag: " + flag);
            }
            
            schema.put(flag, type);
        }
    }

    private void parseArgs(String[] args) throws IllegalArgumentException {
        for (int i = 0; i &lt; args.length; i++) {
            String arg = args[i];
            if (!arg.startsWith("-") || arg.length() != 2) {
                throw new IllegalArgumentException("Invalid argument format: " + arg);
            }

            char flag = arg.charAt(1);
            if (!schema.containsKey(flag)) {
                throw new IllegalArgumentException("Unknown flag: " + flag);
            }

            String type = schema.get(flag);
            if (type.isEmpty()) {  // boolean flag
                parsedArguments.put(flag, "true");
            } else {  // string or integer flag
                if (i + 1 &gt;= args.length) {
                    throw new IllegalArgumentException("No value provided for flag: " + flag);
                }
                parsedArguments.put(flag, args[++i]);
            }
        }
    }

    public boolean getBoolean(char flag) throws IllegalArgumentException {
        validateFlag(flag, "");
        return parsedArguments.containsKey(flag);
    }

    public int getInt(char flag) throws IllegalArgumentException {
        validateFlag(flag, "#");
        try {
            return Integer.parseInt(parsedArguments.getOrDefault(flag, "0"));
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException("Invalid integer value for flag: " + flag);
        }
    }

    public String getString(char flag) throws IllegalArgumentException {
        validateFlag(flag, "*");
        return parsedArguments.getOrDefault(flag, "");
    }

    private void validateFlag(char flag, String expectedType) throws IllegalArgumentException {
        if (!schema.containsKey(flag)) {
            throw new IllegalArgumentException("Unknown flag: " + flag);
        }
        if (!schema.get(flag).equals(expectedType)) {
            throw new IllegalArgumentException("Invalid type for flag: " + flag);
        }
    }
}
</code></pre>
<p>Not perfect, but a much better starting point for discussions about:</p>
<ul>
<li>How to make it easier to add new types</li>
<li>How to improve the schema format</li>
<li>How to make errors more specific</li>
</ul>
<p>The chapter unintentionally demonstrates how TDD alone doesn't guarantee good design - you need solid architectural vision too.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter_13.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter_13.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/book2.js"></script>


    </div>
    </body>
</html>
